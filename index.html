<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Connections UK</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap');

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --bg-primary: #1a1a1a;
            --bg-secondary: #242424;
            --bg-tile: rgba(255, 255, 255, 0.06);
            --bg-tile-hover: rgba(255, 255, 255, 0.1);
            --bg-tile-selected: rgba(255, 255, 255, 0.15);
            --border-tile: rgba(255, 255, 255, 0.1);
            --border-selected: rgba(255, 255, 255, 0.4);
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.6);
            --text-muted: rgba(255, 255, 255, 0.4);

            /* Gradient colors for solved groups - UK Met Office style */
            --gradient-1: linear-gradient(135deg, #22c55e, #16a34a);  /* Green - easiest */
            --gradient-2: linear-gradient(135deg, #eab308, #ca8a04);  /* Yellow */
            --gradient-3: linear-gradient(135deg, #f97316, #ea580c);  /* Amber */
            --gradient-4: linear-gradient(135deg, #ef4444, #dc2626);  /* Red - hardest */
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            min-height: 100dvh;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow-x: hidden;
        }

        /* Noise texture overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.03;
            pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            z-index: 0;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            position: relative;
            z-index: 10;
        }

        .logo-section {
            display: flex;
            flex-direction: column;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 800;
            letter-spacing: 0.15em;
            color: var(--text-primary);
        }

        .tagline {
            font-size: 0.7rem;
            color: var(--text-muted);
            font-weight: 400;
            margin-top: 2px;
        }

        .header-actions {
            display: flex;
            gap: 8px;
        }

        .header-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 1.25rem;
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            transition: all 0.2s ease;
        }

        .header-btn:hover {
            color: var(--text-primary);
            background: rgba(255, 255, 255, 0.05);
        }

        /* Main container */
        .container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 20px 20px;
            position: relative;
            z-index: 1;
            max-width: 520px;
            margin: 0 auto;
            width: 100%;
        }

        /* Mistakes indicator */
        .mistakes-container {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            height: 24px;
            align-items: center;
        }

        .mistake-pip {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--text-secondary);
            transition: all 0.3s ease;
        }

        .mistake-pip.used {
            background: rgba(255, 255, 255, 0.15);
            transform: scale(0.7);
        }

        /* Difficulty legend */
        .difficulty-legend {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            margin-bottom: 16px;
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .difficulty-label {
            font-weight: 500;
        }

        .difficulty-swatches {
            display: flex;
            gap: 4px;
        }

        .difficulty-swatch {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        .difficulty-swatch.swatch-1 { background: var(--gradient-1); }
        .difficulty-swatch.swatch-2 { background: var(--gradient-2); }
        .difficulty-swatch.swatch-3 { background: var(--gradient-3); }
        .difficulty-swatch.swatch-4 { background: var(--gradient-4); }

        /* Solved categories area */
        .solved-area {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 8px;
        }

        .solved-category {
            border-radius: 12px;
            padding: 16px 20px;
            text-align: center;
            opacity: 0;
            transform: scale(0.9);
            animation: solvedReveal 0.5s ease forwards;
        }

        .solved-category.gradient-1 { background: var(--gradient-1); }
        .solved-category.gradient-2 { background: var(--gradient-2); }
        .solved-category.gradient-3 { background: var(--gradient-3); }
        .solved-category.gradient-4 { background: var(--gradient-4); }

        @keyframes solvedReveal {
            0% {
                opacity: 0;
                transform: scale(0.9);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        .solved-category-name {
            font-size: 0.85rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            margin-bottom: 6px;
            text-transform: uppercase;
            color: #ffffff;
        }

        .solved-category-words {
            font-size: 0.8rem;
            font-weight: 400;
            opacity: 0.9;
            letter-spacing: 0.02em;
            color: #ffffff;
        }

        /* Grid */
        .grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            width: 100%;
            margin-bottom: 20px;
        }

        .tile {
            aspect-ratio: 1.2;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px;
            border-radius: 12px;
            background: var(--bg-tile);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border-tile);
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 700;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            text-align: center;
            word-break: break-word;
            transition: all 0.2s ease;
            user-select: none;
            position: relative;
            color: #ffffff;
            overflow: hidden;
        }

        .tile:hover {
            background: var(--bg-tile-hover);
            transform: scale(1.02);
        }

        .tile:active {
            transform: scale(0.98);
        }

        .tile.selected {
            background: var(--bg-tile-selected);
            border-color: var(--border-selected);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1),
                        inset 0 0 20px rgba(255, 255, 255, 0.05);
            animation: selectedPulse 2s ease-in-out infinite;
        }

        @keyframes selectedPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 255, 255, 0.1), inset 0 0 20px rgba(255, 255, 255, 0.05); }
            50% { box-shadow: 0 0 30px rgba(255, 255, 255, 0.2), inset 0 0 25px rgba(255, 255, 255, 0.08); }
        }

        .tile.shake {
            animation: shake 0.5s ease;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-8px); }
            40% { transform: translateX(8px); }
            60% { transform: translateX(-6px); }
            80% { transform: translateX(6px); }
        }

        .tile.solving {
            animation: tileCollapse 0.4s ease forwards;
        }

        @keyframes tileCollapse {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(0.5);
            }
        }

        /* Buttons area */
        .buttons-area {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin-top: auto;
            padding-top: 20px;
            width: 100%;
        }

        .btn {
            padding: 14px 32px;
            border-radius: 100px;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
        }

        .btn-primary {
            background: var(--text-primary);
            color: var(--bg-primary);
        }

        .btn-primary:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 20px rgba(255, 255, 255, 0.2);
        }

        .btn-primary:active {
            transform: scale(0.98);
        }

        .btn-primary:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            border-color: rgba(255, 255, 255, 0.4);
            color: var(--text-primary);
        }

        .submit-btn {
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .submit-btn.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        /* Shuffle button */
        .shuffle-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-muted);
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .shuffle-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
        }

        /* Toast */
        .toast-container {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            pointer-events: none;
        }

        .toast {
            background: rgba(255, 255, 255, 0.95);
            color: var(--bg-primary);
            padding: 12px 24px;
            border-radius: 100px;
            font-weight: 600;
            font-size: 0.9rem;
            animation: toastIn 0.3s ease, toastOut 0.3s ease 1.5s forwards;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        @keyframes toastIn {
            from { opacity: 0; transform: translateY(-20px) scale(0.9); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        @keyframes toastOut {
            from { opacity: 1; transform: translateY(0) scale(1); }
            to { opacity: 0; transform: translateY(-20px) scale(0.9); }
        }

        /* Particles */
        .particle {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            pointer-events: none;
            animation: particleBurst 0.8s ease-out forwards;
        }

        @keyframes particleBurst {
            0% {
                opacity: 1;
                transform: translate(0, 0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(var(--tx), var(--ty)) scale(0);
            }
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 32px;
            max-width: 400px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            transform: scale(0.9) translateY(20px);
            transition: all 0.3s ease;
            position: relative;
        }

        .modal-overlay.visible .modal {
            transform: scale(1) translateY(0);
        }

        .modal-close {
            position: absolute;
            top: 16px;
            right: 16px;
            background: transparent;
            border: none;
            color: var(--text-muted);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 4px;
            line-height: 1;
        }

        .modal-close:hover {
            color: var(--text-primary);
        }

        .modal h2 {
            font-size: 1.25rem;
            font-weight: 700;
            letter-spacing: 0.05em;
            margin-bottom: 20px;
            text-transform: uppercase;
        }

        .modal p {
            color: var(--text-secondary);
            font-size: 0.95rem;
            line-height: 1.6;
            margin-bottom: 16px;
        }

        .modal p:last-child {
            margin-bottom: 0;
        }

        /* Stats modal */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-bottom: 24px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-top: 4px;
        }

        /* Archive modal */
        .modal-archive {
            max-height: 80vh;
        }

        .archive-subtitle {
            color: var(--text-muted);
            font-size: 0.85rem;
            margin-bottom: 20px;
        }

        .archive-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 400px;
            overflow-y: auto;
            padding-right: 8px;
        }

        .archive-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .archive-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .archive-item.played {
            cursor: default;
        }

        .archive-item-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .archive-item-date {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-primary);
        }

        .archive-item-number {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .archive-item-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .archive-item-result {
            display: flex;
            gap: 2px;
        }

        .archive-item-result span {
            font-size: 0.7rem;
        }

        .archive-item-badge {
            font-size: 0.7rem;
            padding: 4px 10px;
            border-radius: 100px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .archive-item-badge.won {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
        }

        .archive-item-badge.lost {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .archive-item-badge.play {
            background: var(--text-primary);
            color: var(--bg-primary);
        }

        /* League widget */
        .league-widget {
            width: 100%;
            margin-bottom: 20px;
        }

        .league-widget-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .league-widget-title {
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
        }

        .league-widget-create {
            font-size: 0.75rem;
            color: var(--text-muted);
            background: none;
            border: none;
            cursor: pointer;
            text-decoration: underline;
            padding: 0;
        }

        .league-widget-create:hover {
            color: var(--text-primary);
        }

        .league-widget-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .league-widget-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 14px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            font-size: 0.85rem;
        }

        .league-widget-name {
            font-weight: 500;
            color: var(--text-primary);
        }

        .league-widget-count {
            color: var(--text-muted);
            font-size: 0.75rem;
        }

        .league-widget-empty {
            text-align: center;
            padding: 16px;
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        .league-widget-empty a {
            color: var(--text-secondary);
        }

        /* League modal inputs */
        .modal-input {
            width: 100%;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.95rem;
            margin-bottom: 16px;
        }

        .modal-input:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.3);
        }

        .modal-input::placeholder {
            color: var(--text-muted);
        }

        .modal-btn {
            width: 100%;
            padding: 14px;
            background: var(--text-primary);
            color: var(--bg-primary);
            border: none;
            border-radius: 100px;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modal-btn:hover {
            transform: scale(1.02);
        }

        .modal-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .league-url-container {
            margin-top: 16px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .league-url-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .league-url {
            display: flex;
            gap: 8px;
        }

        .league-url input {
            flex: 1;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 6px;
            color: var(--text-primary);
            font-family: monospace;
            font-size: 0.8rem;
        }

        .league-url button {
            padding: 8px 16px;
            background: var(--text-primary);
            color: var(--bg-primary);
            border: none;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
        }

        /* Leaderboard */
        .leaderboard-section {
            width: 100%;
            max-width: 400px;
            margin-top: 24px;
        }

        .leaderboard-title {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-primary);
        }

        .leaderboard-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .leaderboard-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 14px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .leaderboard-item.current-player {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .leaderboard-rank {
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--text-muted);
            min-width: 24px;
        }

        .leaderboard-name {
            flex: 1;
            font-size: 0.85rem;
            color: var(--text-primary);
        }

        .leaderboard-mistakes {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .leaderboard-not-played {
            font-size: 0.75rem;
            color: var(--text-muted);
            font-style: italic;
        }

        .leaderboards-container {
            display: flex;
            flex-direction: column;
            gap: 24px;
            width: 100%;
            max-width: 400px;
            margin-top: 24px;
            max-height: 300px;
            overflow-y: auto;
        }

        /* Player rankings on end screen */
        .player-rankings {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
            max-width: 350px;
            margin-bottom: 20px;
        }

        .player-rank-card {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .player-rank-league {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .player-rank-position {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .player-rank-position strong {
            color: var(--text-primary);
            font-weight: 700;
        }

        /* League modal navigation */
        .league-nav {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            margin-bottom: 8px;
        }

        .league-nav h2 {
            flex: 1;
            text-align: center;
            margin: 0;
            font-size: 1.1rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .league-nav-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: var(--text-primary);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .league-nav-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .league-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .league-indicator {
            text-align: center;
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 16px;
        }

        #leagueModalLeaderboard {
            max-height: 350px;
            overflow-y: auto;
        }

        /* End screen */
        .end-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            z-index: 1500;
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s ease;
        }

        .end-screen.visible {
            opacity: 1;
            visibility: visible;
        }

        .end-message {
            font-size: 1.75rem;
            font-weight: 700;
            letter-spacing: 0.05em;
            margin-bottom: 32px;
            text-align: center;
        }

        .end-categories {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
            max-width: 400px;
            margin-bottom: 32px;
        }

        .end-category {
            border-radius: 12px;
            padding: 14px 18px;
            text-align: center;
            opacity: 0;
            transform: translateY(20px);
        }

        .end-category.revealed {
            animation: categoryReveal 0.5s ease forwards;
        }

        @keyframes categoryReveal {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .countdown-section {
            text-align: center;
            margin-top: 24px;
        }

        .countdown-label {
            font-size: 0.8rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 8px;
        }

        .countdown-time {
            font-size: 1.5rem;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        /* Loading state */
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 300px;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--text-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 16px;
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        /* No puzzle state */
        .no-puzzle {
            text-align: center;
            padding: 60px 20px;
        }

        .no-puzzle h2 {
            font-size: 1.25rem;
            margin-bottom: 12px;
        }

        .no-puzzle p {
            color: var(--text-secondary);
        }

        /* Hidden utility */
        .hidden {
            display: none !important;
        }

        /* Responsive */
        @media (max-width: 480px) {
            .header {
                padding: 12px 16px;
            }

            .logo {
                font-size: 1.25rem;
            }

            .container {
                padding: 0 12px 12px;
            }

            .grid {
                gap: 6px;
            }

            .tile {
                font-size: 0.65rem;
                border-radius: 10px;
                padding: 6px;
            }

            .solved-category {
                padding: 12px 16px;
            }

            .solved-category-name {
                font-size: 0.75rem;
            }

            .solved-category-words {
                font-size: 0.7rem;
            }

            .btn {
                padding: 12px 24px;
                font-size: 0.85rem;
            }

            .shuffle-btn {
                width: 44px;
                height: 44px;
                bottom: 12px;
                right: 12px;
            }
        }

        @media (max-width: 360px) {
            .tile {
                font-size: 0.6rem;
                letter-spacing: 0.04em;
            }

            .buttons-area {
                flex-direction: column;
                gap: 8px;
            }

            .btn {
                width: 100%;
            }
        }

        /* Landscape phones */
        @media (max-height: 500px) and (orientation: landscape) {
            .container {
                padding-top: 8px;
            }

            .mistakes-container {
                margin-bottom: 12px;
            }

            .tile {
                aspect-ratio: 1.5;
            }

            .buttons-area {
                padding-top: 12px;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo-section">
            <div class="logo">CONNECTIONS UK</div>
            <div class="tagline">The game you know and love, without the Americanisms.</div>
        </div>
        <div class="header-actions">
            <button class="header-btn" id="archiveBtn" aria-label="Archive">&#x1F4C5;</button>
            <button class="header-btn" id="rulesBtn" aria-label="How to play">?</button>
            <button class="header-btn" id="statsBtn" aria-label="Statistics">&#x1F4CA;</button>
        </div>
    </header>

    <main class="container">
        <!-- Loading state -->
        <div class="loading" id="loading">
            <div class="loading-spinner"></div>
            <div class="loading-text">Loading puzzle...</div>
        </div>

        <!-- No puzzle state -->
        <div class="no-puzzle hidden" id="noPuzzle">
            <h2>No puzzle today</h2>
            <p>Check back tomorrow for a new challenge.</p>
        </div>

        <!-- League widget -->
        <div class="league-widget hidden" id="leagueWidget">
            <div class="league-widget-header">
                <span class="league-widget-title">Your Leagues</span>
                <button class="league-widget-create" id="createLeagueBtn">+ Create League</button>
            </div>
            <div class="league-widget-list" id="leagueWidgetList">
                <!-- Populated by JavaScript -->
            </div>
        </div>

        <!-- Game area -->
        <div class="game-area hidden" id="gameArea">
            <div class="mistakes-container" id="mistakes">
                <div class="mistake-pip"></div>
                <div class="mistake-pip"></div>
                <div class="mistake-pip"></div>
                <div class="mistake-pip"></div>
            </div>

            <div class="difficulty-legend">
                <span class="difficulty-label">Easy</span>
                <div class="difficulty-swatches">
                    <div class="difficulty-swatch swatch-1"></div>
                    <div class="difficulty-swatch swatch-2"></div>
                    <div class="difficulty-swatch swatch-3"></div>
                    <div class="difficulty-swatch swatch-4"></div>
                </div>
                <span class="difficulty-label">Hard</span>
            </div>

            <div class="solved-area" id="solvedArea"></div>

            <div class="grid" id="grid"></div>

            <div class="buttons-area">
                <button class="btn btn-secondary" id="deselectBtn">Deselect All</button>
                <button class="btn btn-primary submit-btn" id="submitBtn" disabled>Submit</button>
            </div>
        </div>
    </main>

    <button class="shuffle-btn" id="shuffleBtn" aria-label="Shuffle tiles">&#x1F500;</button>

    <!-- Toast container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Rules Modal -->
    <div class="modal-overlay" id="rulesModal">
        <div class="modal">
            <button class="modal-close" aria-label="Close">&times;</button>
            <h2>How to Play</h2>
            <p>Sixteen words. Four groups. Sounds simple. It isn't.</p>
            <p>Find the connections &mdash; but watch out, some words are deliberately misleading. You've got four mistakes before it's all over.</p>
            <p>Tap four words you think belong together, then hit Submit. If you're right, they'll disappear and reveal their connection. If you're wrong, you'll lose a life.</p>
            <p>The colours indicate difficulty, Met Office style: green is the friendliest, red is... well, you've been warned.</p>
        </div>
    </div>

    <!-- Stats Modal -->
    <div class="modal-overlay" id="statsModal">
        <div class="modal">
            <button class="modal-close" aria-label="Close">&times;</button>
            <h2>Statistics</h2>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="statPlayed">0</div>
                    <div class="stat-label">Played</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="statWinRate">0%</div>
                    <div class="stat-label">Win %</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="statStreak">0</div>
                    <div class="stat-label">Streak</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Archive Modal -->
    <div class="modal-overlay" id="archiveModal">
        <div class="modal modal-archive">
            <button class="modal-close" aria-label="Close">&times;</button>
            <h2>Archive</h2>
            <p class="archive-subtitle">Play puzzles you've missed or revisit your results.</p>
            <div class="archive-list" id="archiveList">
                <!-- Populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Create League Modal -->
    <div class="modal-overlay" id="createLeagueModal">
        <div class="modal">
            <button class="modal-close" aria-label="Close">&times;</button>
            <h2 id="createLeagueTitle">Create a League</h2>
            <div id="createLeagueForm">
                <p>Start a league and invite your mates to compete daily.</p>
                <input type="text" class="modal-input" id="leagueNameInput" placeholder="League name (e.g. Flat 4)" maxlength="50">
                <button class="modal-btn" id="createLeagueSubmit">Create League</button>
            </div>
            <div class="league-url-container hidden" id="leagueUrlContainer">
                <p id="leagueCreatedName" style="margin-bottom: 12px; font-weight: 600;"></p>
                <div class="league-url-label">Share this link with your mates</div>
                <div class="league-url">
                    <input type="text" id="leagueUrlInput" readonly>
                    <button id="copyLeagueUrl">Copy</button>
                </div>
                <button class="modal-btn" id="createAnotherBtn" style="margin-top: 16px; background: transparent; border: 1px solid rgba(255,255,255,0.2); color: var(--text-secondary);">Create Another League</button>
            </div>
        </div>
    </div>

    <!-- Join League Modal (Name Prompt) -->
    <div class="modal-overlay" id="joinLeagueModal">
        <div class="modal">
            <h2>Join <span id="joinLeagueName"></span></h2>
            <p>Enter your display name to join this league.</p>
            <input type="text" class="modal-input" id="playerNameInput" placeholder="Your name" maxlength="30">
            <button class="modal-btn" id="joinLeagueSubmit">Join League</button>
        </div>
    </div>

    <!-- End Screen -->
    <div class="end-screen" id="endScreen">
        <div class="end-message" id="endMessage">Sorted.</div>
        <div class="end-categories" id="endCategories"></div>
        <div class="player-rankings hidden" id="playerRankings">
            <!-- Shows player's rank in each league -->
        </div>
        <div class="buttons-area">
            <button class="btn btn-secondary hidden" id="viewLeaguesBtn">View Leagues</button>
            <button class="btn btn-primary" id="shareBtn">Share Result</button>
        </div>
        <div class="countdown-section">
            <div class="countdown-label">Next puzzle in</div>
            <div class="countdown-time" id="countdown">--:--:--</div>
        </div>
    </div>

    <!-- View Leagues Modal -->
    <div class="modal-overlay" id="viewLeaguesModal">
        <div class="modal" style="max-width: 450px;">
            <button class="modal-close" aria-label="Close" style="top: 12px; right: 12px;">&times;</button>
            <div class="league-nav" style="margin-top: 16px;">
                <button class="league-nav-btn" id="prevLeagueBtn">&larr;</button>
                <h2 id="leagueModalTitle">League Name</h2>
                <button class="league-nav-btn" id="nextLeagueBtn">&rarr;</button>
            </div>
            <div class="league-indicator" id="leagueIndicator">1 / 3</div>
            <div class="leaderboard-list" id="leagueModalLeaderboard">
                <!-- Populated by JavaScript -->
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // ===== CONFIGURATION =====
        const SHEET_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRVce17rCXo1SJkPhMK0R1P4ytJAG5In25KcP66a5aNE4KEtg7u_0oQGuQzgL3-MiGUdI0_4BmQXGYK/pub?output=csv';
        const GRADIENT_CLASSES = ['gradient-1', 'gradient-2', 'gradient-3', 'gradient-4'];
        const SHARE_EMOJIS = ['ðŸŸ©', 'ðŸŸ¨', 'ðŸŸ§', 'ðŸŸ¥']; // Green, Yellow, Amber, Red - UK Met Office style

        // Supabase configuration
        const SUPABASE_URL = 'https://bwybtkrfgepsoeuvxvmf.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJ3eWJ0a3JmZ2Vwc29ldXZ4dm1mIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzIwNjIzMzcsImV4cCI6MjA4NzYzODMzN30.aF5KTncfws-grjCkgwQD47fUSkTuJC6-gJMhB0JC0F4';
        const db = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // ===== STATE =====
        let allPuzzles = [];
        let currentPuzzle = null;
        let currentDate = null; // The date of the puzzle being played
        let remainingWords = [];
        let selectedWords = [];
        let solvedCategories = [];
        let mistakes = 0;
        let gameOver = false;
        let guessHistory = [];
        let puzzleNumber = 1;

        // ===== DOM ELEMENTS =====
        const loadingEl = document.getElementById('loading');
        const noPuzzleEl = document.getElementById('noPuzzle');
        const gameAreaEl = document.getElementById('gameArea');
        const gridEl = document.getElementById('grid');
        const solvedAreaEl = document.getElementById('solvedArea');
        const mistakesEl = document.getElementById('mistakes');
        const submitBtn = document.getElementById('submitBtn');
        const deselectBtn = document.getElementById('deselectBtn');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const rulesBtn = document.getElementById('rulesBtn');
        const statsBtn = document.getElementById('statsBtn');
        const archiveBtn = document.getElementById('archiveBtn');
        const rulesModal = document.getElementById('rulesModal');
        const statsModal = document.getElementById('statsModal');
        const archiveModal = document.getElementById('archiveModal');
        const archiveList = document.getElementById('archiveList');
        const endScreen = document.getElementById('endScreen');
        const endMessage = document.getElementById('endMessage');
        const endCategories = document.getElementById('endCategories');
        const shareBtn = document.getElementById('shareBtn');
        const countdownEl = document.getElementById('countdown');
        const toastContainer = document.getElementById('toastContainer');

        // League elements
        const leagueWidget = document.getElementById('leagueWidget');
        const leagueWidgetList = document.getElementById('leagueWidgetList');
        const createLeagueBtn = document.getElementById('createLeagueBtn');
        const createLeagueModal = document.getElementById('createLeagueModal');
        const leagueNameInput = document.getElementById('leagueNameInput');
        const createLeagueSubmit = document.getElementById('createLeagueSubmit');
        const leagueUrlContainer = document.getElementById('leagueUrlContainer');
        const leagueUrlInput = document.getElementById('leagueUrlInput');
        const copyLeagueUrl = document.getElementById('copyLeagueUrl');
        const joinLeagueModal = document.getElementById('joinLeagueModal');
        const joinLeagueName = document.getElementById('joinLeagueName');
        const playerNameInput = document.getElementById('playerNameInput');
        const joinLeagueSubmit = document.getElementById('joinLeagueSubmit');
        const leaderboardsContainer = document.getElementById('leaderboardsContainer');

        // League state
        let playerUUID = localStorage.getItem('player-uuid');
        let playerName = localStorage.getItem('player-name');
        let playerLeagues = [];
        let pendingLeagueId = null; // League to join after name entry

        // ===== UTILITY FUNCTIONS =====
        function getTodayString() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function normalizeDate(dateStr) {
            if (!dateStr) return null;

            // Already in YYYY-MM-DD format
            if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                return dateStr;
            }

            // MM/DD/YYYY format
            if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(dateStr)) {
                const parts = dateStr.split('/');
                const month = parts[0].padStart(2, '0');
                const day = parts[1].padStart(2, '0');
                const year = parts[2];
                return `${year}-${month}-${day}`;
            }

            // DD/MM/YYYY format (British)
            if (/^\d{1,2}-\d{1,2}-\d{4}$/.test(dateStr)) {
                const parts = dateStr.split('-');
                const day = parts[0].padStart(2, '0');
                const month = parts[1].padStart(2, '0');
                const year = parts[2];
                return `${year}-${month}-${day}`;
            }

            // Excel serial date number
            if (!isNaN(dateStr) && Number(dateStr) > 40000) {
                const excelDate = new Date((Number(dateStr) - 25569) * 86400 * 1000);
                const year = excelDate.getFullYear();
                const month = String(excelDate.getMonth() + 1).padStart(2, '0');
                const day = String(excelDate.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            }

            return null;
        }

        function shuffle(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function formatDateForDisplay(dateStr) {
            const date = new Date(dateStr + 'T00:00:00');
            return date.toLocaleDateString('en-GB', {
                day: 'numeric',
                month: 'long',
                year: 'numeric'
            });
        }

        function getTimeUntilMidnight() {
            const now = new Date();
            const midnight = new Date(now);
            midnight.setHours(24, 0, 0, 0);
            return midnight - now;
        }

        function formatCountdown(ms) {
            const hours = Math.floor(ms / (1000 * 60 * 60));
            const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((ms % (1000 * 60)) / 1000);
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        // ===== TOAST =====
        function showToast(message) {
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            toastContainer.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        }

        // ===== PARTICLES =====
        function createParticles(x, y, color) {
            for (let i = 0; i < 12; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;
                particle.style.background = color;

                const angle = (i / 12) * Math.PI * 2;
                const distance = 40 + Math.random() * 40;
                particle.style.setProperty('--tx', `${Math.cos(angle) * distance}px`);
                particle.style.setProperty('--ty', `${Math.sin(angle) * distance}px`);

                document.body.appendChild(particle);
                setTimeout(() => particle.remove(), 800);
            }
        }

        // ===== STATS =====
        function getStats() {
            const stored = localStorage.getItem('linked-stats');
            return stored ? JSON.parse(stored) : {
                played: {},
                streak: 0,
                maxStreak: 0
            };
        }

        function saveStats(stats) {
            localStorage.setItem('linked-stats', JSON.stringify(stats));
        }

        function updateStatsDisplay() {
            const stats = getStats();
            const playedCount = Object.keys(stats.played).length;
            const wins = Object.values(stats.played).filter(p => p.won).length;
            const winRate = playedCount > 0 ? Math.round((wins / playedCount) * 100) : 0;

            document.getElementById('statPlayed').textContent = playedCount;
            document.getElementById('statWinRate').textContent = `${winRate}%`;
            document.getElementById('statStreak').textContent = stats.streak;
        }

        function hasPlayedToday() {
            const stats = getStats();
            return stats.played[getTodayString()] !== undefined;
        }

        function getTodayResult() {
            const stats = getStats();
            return stats.played[getTodayString()];
        }

        // ===== PLAYER/LEAGUE MANAGEMENT =====
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        function ensurePlayerUUID() {
            if (!playerUUID) {
                playerUUID = generateUUID();
                localStorage.setItem('player-uuid', playerUUID);
            }
            return playerUUID;
        }

        function setPlayerName(name) {
            playerName = name;
            localStorage.setItem('player-name', name);
        }

        async function fetchPlayerLeagues() {
            console.log('fetchPlayerLeagues called, playerUUID:', playerUUID);
            if (!playerUUID) return [];
            try {
                const today = getTodayString();

                // Get all leagues the player is in
                const { data: memberships, error } = await db
                    .from('league_memberships')
                    .select('league_id, leagues(id, name)')
                    .eq('player_uuid', playerUUID);

                console.log('Memberships query result:', { memberships, error });

                if (!memberships || memberships.length === 0) {
                    playerLeagues = [];
                    return [];
                }

                // Get stats for each league
                const leagues = await Promise.all(memberships.map(async m => {
                    const { count: totalMembers } = await db
                        .from('league_memberships')
                        .select('*', { count: 'exact', head: true })
                        .eq('league_id', m.league_id);

                    const { count: playedToday } = await db
                        .from('daily_scores')
                        .select('*', { count: 'exact', head: true })
                        .eq('league_id', m.league_id)
                        .eq('date', today);

                    return {
                        id: m.league_id,
                        name: m.leagues?.name || 'Unknown',
                        total_members: totalMembers || 0,
                        played_today: playedToday || 0
                    };
                }));

                playerLeagues = leagues;
                return playerLeagues;
            } catch (error) {
                console.error('Error fetching leagues:', error);
                return [];
            }
        }

        async function renderLeagueWidget() {
            const leagues = await fetchPlayerLeagues();

            if (leagues.length === 0) {
                leagueWidgetList.innerHTML = `
                    <div class="league-widget-empty">
                        No leagues yet. <a href="#" id="createLeagueLink">Create one</a> or join via a shared link.
                    </div>
                `;
                const createLink = document.getElementById('createLeagueLink');
                if (createLink) {
                    createLink.addEventListener('click', (e) => {
                        e.preventDefault();
                        openModal(createLeagueModal);
                    });
                }
            } else {
                leagueWidgetList.innerHTML = leagues.map(league => `
                    <div class="league-widget-item">
                        <span class="league-widget-name">${league.name}</span>
                        <span class="league-widget-count">${league.played_today}/${league.total_members} played today</span>
                    </div>
                `).join('');
            }

            leagueWidget.classList.remove('hidden');
        }

        async function createLeague(name) {
            try {
                // Generate a short ID
                const id = crypto.randomUUID().slice(0, 8);

                const { error } = await db
                    .from('leagues')
                    .insert({ id, name: name.trim() });

                if (error) throw error;

                // Auto-join the league we created
                ensurePlayerUUID();
                if (playerName) {
                    await joinLeague(id);
                }

                const url = `${window.location.origin}/league/${id}`;
                return { id, name: name.trim(), url };
            } catch (error) {
                console.error('Error creating league:', error);
                throw error;
            }
        }

        async function joinLeague(leagueId) {
            ensurePlayerUUID();
            if (!playerName) {
                // Need to prompt for name first
                pendingLeagueId = leagueId;
                const { data: league } = await db
                    .from('leagues')
                    .select('*')
                    .eq('id', leagueId)
                    .single();
                joinLeagueName.textContent = league?.name || 'League';
                openModal(joinLeagueModal);
                return false;
            }

            try {
                // Upsert player
                await db
                    .from('players')
                    .upsert({ uuid: playerUUID, display_name: playerName.trim() }, { onConflict: 'uuid' });

                // Add membership if not exists
                await db
                    .from('league_memberships')
                    .upsert({ player_uuid: playerUUID, league_id: leagueId }, { onConflict: 'player_uuid,league_id', ignoreDuplicates: true });

                await fetchPlayerLeagues();
                return true;
            } catch (error) {
                console.error('Error joining league:', error);
                throw error;
            }
        }

        async function submitScore(mistakeCount) {
            if (!playerUUID || playerLeagues.length === 0) return;

            try {
                // Insert/update score for each league the player is in
                for (const league of playerLeagues) {
                    await db
                        .from('daily_scores')
                        .upsert(
                            { player_uuid: playerUUID, league_id: league.id, date: currentDate, mistakes: mistakeCount },
                            { onConflict: 'player_uuid,league_id,date' }
                        );
                }
            } catch (error) {
                console.error('Error submitting score:', error);
            }
        }

        async function fetchLeaderboards() {
            if (playerLeagues.length === 0) return [];

            const leaderboards = [];
            for (const league of playerLeagues) {
                try {
                    // Get all members with their player info
                    const { data: memberships } = await db
                        .from('league_memberships')
                        .select('player_uuid, players(uuid, display_name)')
                        .eq('league_id', league.id);

                    // Get scores for this date
                    const { data: scores } = await db
                        .from('daily_scores')
                        .select('*')
                        .eq('league_id', league.id)
                        .eq('date', currentDate);

                    // Build member list with scores
                    const members = (memberships || []).map(m => {
                        const score = (scores || []).find(s => s.player_uuid === m.player_uuid);
                        return {
                            uuid: m.player_uuid,
                            display_name: m.players?.display_name || 'Unknown',
                            mistakes: score?.mistakes ?? null,
                            date: score?.date ?? null
                        };
                    });

                    // Sort: played first (by mistakes), then not played (alphabetically)
                    members.sort((a, b) => {
                        if (a.mistakes !== null && b.mistakes !== null) {
                            return a.mistakes - b.mistakes;
                        }
                        if (a.mistakes !== null) return -1;
                        if (b.mistakes !== null) return 1;
                        return a.display_name.localeCompare(b.display_name);
                    });

                    // Calculate ranks
                    let currentRank = 0;
                    let lastMistakes = null;
                    let playedCount = 0;

                    const leaderboard = members.map((member) => {
                        if (member.mistakes !== null) {
                            playedCount++;
                            if (member.mistakes !== lastMistakes) {
                                currentRank = playedCount;
                                lastMistakes = member.mistakes;
                            }
                            return { ...member, rank: currentRank };
                        }
                        return { ...member, rank: null };
                    });

                    leaderboards.push({
                        league: { id: league.id, name: league.name },
                        date: currentDate,
                        leaderboard
                    });
                } catch (error) {
                    console.error('Error fetching leaderboard:', error);
                }
            }
            return leaderboards;
        }

        // Store leaderboards for modal navigation
        let cachedLeaderboards = [];
        let currentLeagueIndex = 0;

        function renderPlayerRankings(leaderboards) {
            const playerRankings = document.getElementById('playerRankings');

            if (leaderboards.length === 0) {
                playerRankings.classList.add('hidden');
                return;
            }

            playerRankings.innerHTML = leaderboards.map(lb => {
                const me = lb.leaderboard.find(p => p.uuid === playerUUID);
                const totalPlayers = lb.leaderboard.length;
                const rankText = me?.rank ? `<strong>#${me.rank}</strong> of ${totalPlayers}` : 'Not ranked';

                return `
                    <div class="player-rank-card">
                        <span class="player-rank-league">${lb.league.name}</span>
                        <span class="player-rank-position">${rankText}</span>
                    </div>
                `;
            }).join('');

            playerRankings.classList.remove('hidden');
        }

        function renderLeagueModal(index) {
            if (cachedLeaderboards.length === 0) return;

            currentLeagueIndex = index;
            const lb = cachedLeaderboards[index];

            document.getElementById('leagueModalTitle').textContent = lb.league.name;
            document.getElementById('leagueIndicator').textContent = `${index + 1} / ${cachedLeaderboards.length}`;

            document.getElementById('prevLeagueBtn').disabled = index === 0;
            document.getElementById('nextLeagueBtn').disabled = index === cachedLeaderboards.length - 1;

            document.getElementById('leagueModalLeaderboard').innerHTML = lb.leaderboard.map(player => `
                <div class="leaderboard-item ${player.uuid === playerUUID ? 'current-player' : ''}">
                    <span class="leaderboard-rank">${player.rank !== null ? '#' + player.rank : '-'}</span>
                    <span class="leaderboard-name">${player.display_name}</span>
                    ${player.mistakes !== null
                        ? `<span class="leaderboard-mistakes">${player.mistakes} mistake${player.mistakes !== 1 ? 's' : ''}</span>`
                        : `<span class="leaderboard-not-played">not yet played</span>`
                    }
                </div>
            `).join('');
        }

        async function checkLeagueUrl() {
            const path = window.location.pathname;
            const match = path.match(/^\/league\/([a-zA-Z0-9-]+)$/);

            if (match) {
                const leagueId = match[1];
                ensurePlayerUUID();

                // Check if already a member
                try {
                    const { data } = await db
                        .from('league_memberships')
                        .select('*')
                        .eq('league_id', leagueId)
                        .eq('player_uuid', playerUUID)
                        .single();

                    if (!data) {
                        // Need to join
                        await joinLeague(leagueId);
                    }
                } catch (error) {
                    // No membership found, try to join
                    await joinLeague(leagueId);
                }

                // Clear the URL to avoid re-joining on refresh
                window.history.replaceState({}, '', '/');
            }
        }

        // ===== CSV PARSING =====
        function parseCSV(text) {
            const lines = text.trim().split('\n');
            const result = [];

            for (const line of lines) {
                const row = [];
                let current = '';
                let inQuotes = false;

                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        row.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                row.push(current.trim());
                result.push(row);
            }
            return result;
        }

        // ===== PUZZLE FETCHING =====
        async function fetchPuzzles() {
            try {
                // Add cache-busting timestamp to always get fresh data
                const cacheBuster = `&_=${Date.now()}`;
                const response = await fetch(SHEET_URL + cacheBuster, {
                    cache: 'no-store'
                });

                if (!response.ok) {
                    throw new Error('Failed to fetch puzzles');
                }

                const text = await response.text();
                const data = parseCSV(text);

                // Parse rows into puzzles
                const puzzles = [];
                for (let i = 1; i < data.length; i++) {
                    const row = data[i];
                    if (!row || !row[0]) continue;

                    const date = normalizeDate(String(row[0]));
                    if (!date) continue;

                    const parseWords = (str) => {
                        if (!str) return [];
                        return String(str).split(',').map(w => w.trim().toUpperCase()).filter(w => w);
                    };

                    puzzles.push({
                        date: date,
                        categories: [
                            { name: row[1] || '', colour: 'gradient-1', words: parseWords(row[2]) },
                            { name: row[3] || '', colour: 'gradient-2', words: parseWords(row[4]) },
                            { name: row[5] || '', colour: 'gradient-3', words: parseWords(row[6]) },
                            { name: row[7] || '', colour: 'gradient-4', words: parseWords(row[8]) }
                        ]
                    });
                }

                // Calculate puzzle number
                puzzles.sort((a, b) => a.date.localeCompare(b.date));
                const today = getTodayString();
                const todayIndex = puzzles.findIndex(p => p.date === today);
                if (todayIndex >= 0) {
                    puzzleNumber = todayIndex + 1;
                }

                return puzzles;
            } catch (error) {
                console.error('Error fetching puzzles:', error);
                return [];
            }
        }

        // ===== RENDER =====
        function renderGrid() {
            gridEl.innerHTML = '';
            remainingWords.forEach((word) => {
                const tile = document.createElement('button');
                tile.className = 'tile';
                tile.textContent = word;
                tile.dataset.word = word;
                if (selectedWords.includes(word)) {
                    tile.classList.add('selected');
                }
                tile.addEventListener('click', () => handleTileClick(word));
                gridEl.appendChild(tile);
            });
        }

        function renderMistakes() {
            const pips = mistakesEl.querySelectorAll('.mistake-pip');
            pips.forEach((pip, i) => {
                pip.classList.toggle('used', i < mistakes);
            });
        }

        function renderSolvedCategory(category) {
            const el = document.createElement('div');
            el.className = `solved-category ${category.colour}`;
            el.innerHTML = `
                <div class="solved-category-name">${category.name}</div>
                <div class="solved-category-words">${category.words.join(', ')}</div>
            `;
            solvedAreaEl.appendChild(el);
        }

        function updateButtons() {
            submitBtn.disabled = selectedWords.length !== 4;
            submitBtn.classList.toggle('visible', selectedWords.length === 4);
            deselectBtn.style.opacity = selectedWords.length > 0 ? '1' : '0.5';
        }

        // ===== GAME LOGIC =====
        function handleTileClick(word) {
            if (gameOver) return;

            if (selectedWords.includes(word)) {
                selectedWords = selectedWords.filter(w => w !== word);
            } else if (selectedWords.length < 4) {
                selectedWords.push(word);
            }

            renderGrid();
            updateButtons();
        }

        function checkGuess() {
            for (const category of currentPuzzle.categories) {
                if (solvedCategories.includes(category)) continue;
                const matches = selectedWords.filter(w => category.words.includes(w));
                if (matches.length === 4) {
                    return { correct: true, category };
                }
            }
            return { correct: false };
        }

        function checkOneAway() {
            for (const category of currentPuzzle.categories) {
                if (solvedCategories.includes(category)) continue;
                const matches = selectedWords.filter(w => category.words.includes(w));
                if (matches.length === 3) {
                    return true;
                }
            }
            return false;
        }

        async function handleSubmit() {
            if (selectedWords.length !== 4 || gameOver) return;

            const categoryIndex = currentPuzzle.categories.findIndex(cat => {
                if (solvedCategories.includes(cat)) return false;
                return selectedWords.every(w => cat.words.includes(w));
            });

            if (categoryIndex !== -1) {
                guessHistory.push(categoryIndex);
            } else {
                guessHistory.push(-1);
            }

            const result = checkGuess();

            if (result.correct) {
                await animateCorrectGuess(result.category);
            } else {
                await animateWrongGuess();
            }
        }

        async function animateCorrectGuess(category) {
            // Get tiles and their positions for particles
            const tiles = document.querySelectorAll('.tile.selected');
            const gridRect = gridEl.getBoundingClientRect();

            // Add solving animation
            tiles.forEach(tile => tile.classList.add('solving'));

            await sleep(400);

            // Create particles at center
            const centerX = gridRect.left + gridRect.width / 2;
            const centerY = gridRect.top + gridRect.height / 2;
            const colors = ['#22c55e', '#eab308', '#f97316', '#ef4444']; // Green, Yellow, Amber, Red
            const colorIndex = GRADIENT_CLASSES.indexOf(category.colour);
            createParticles(centerX, centerY, colors[colorIndex]);

            // Update state
            solvedCategories.push(category);
            remainingWords = remainingWords.filter(w => !category.words.includes(w));
            selectedWords = [];

            renderSolvedCategory(category);
            renderGrid();
            updateButtons();

            if (solvedCategories.length === 4) {
                await sleep(500);
                handleWin();
            }
        }

        async function animateWrongGuess() {
            const isOneAway = checkOneAway();
            const tiles = document.querySelectorAll('.tile.selected');

            tiles.forEach(tile => tile.classList.add('shake'));
            await sleep(500);
            tiles.forEach(tile => tile.classList.remove('shake'));

            if (isOneAway) {
                showToast('One away...');
            }

            mistakes++;
            renderMistakes();
            selectedWords = [];
            renderGrid();
            updateButtons();

            if (mistakes >= 4) {
                await sleep(300);
                handleLoss();
            }
        }

        async function handleWin() {
            gameOver = true;

            const stats = getStats();

            stats.played[currentDate] = {
                won: true,
                mistakes: mistakes,
                guessHistory: guessHistory
            };

            // Only update streak if playing today's puzzle
            const today = getTodayString();
            if (currentDate === today) {
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                const yesterdayStr = yesterday.toISOString().split('T')[0];

                if (stats.played[yesterdayStr]?.won) {
                    stats.streak++;
                } else {
                    stats.streak = 1;
                }
                stats.maxStreak = Math.max(stats.maxStreak, stats.streak);
            }

            saveStats(stats);
            updateStatsDisplay();

            // Submit score to leagues
            await submitScore(mistakes);

            // Pick win message
            const winMessages = mistakes === 0
                ? ['Clean sweep.', 'Flawless.', 'Textbook.']
                : ['Sorted.', 'Not bad at all.', 'Well played.', 'Nicely done.'];
            endMessage.textContent = winMessages[Math.floor(Math.random() * winMessages.length)];

            // Fetch and render player rankings
            cachedLeaderboards = await fetchLeaderboards();
            renderPlayerRankings(cachedLeaderboards);

            showEndScreen();
        }

        async function handleLoss() {
            gameOver = true;

            const stats = getStats();

            stats.played[currentDate] = {
                won: false,
                mistakes: mistakes,
                guessHistory: guessHistory
            };

            // Only reset streak if playing today's puzzle
            const today = getTodayString();
            if (currentDate === today) {
                stats.streak = 0;
            }
            saveStats(stats);
            updateStatsDisplay();

            // Submit score to leagues (4 mistakes = loss)
            await submitScore(mistakes);

            // Reveal remaining categories
            for (const cat of currentPuzzle.categories) {
                if (!solvedCategories.includes(cat)) {
                    solvedCategories.push(cat);
                    renderSolvedCategory(cat);
                    remainingWords = remainingWords.filter(w => !cat.words.includes(w));
                    renderGrid();
                    await sleep(400);
                }
            }

            const loseMessages = ['Better luck tomorrow.', 'Tough one today.', 'They can\'t all be winners.'];
            endMessage.textContent = loseMessages[Math.floor(Math.random() * loseMessages.length)];

            // Fetch and render player rankings
            cachedLeaderboards = await fetchLeaderboards();
            renderPlayerRankings(cachedLeaderboards);

            showEndScreen();
        }

        function showEndScreen() {
            // Build end categories
            endCategories.innerHTML = '';
            currentPuzzle.categories.forEach((cat, i) => {
                const el = document.createElement('div');
                el.className = `solved-category ${cat.colour} end-category`;
                el.innerHTML = `
                    <div class="solved-category-name">${cat.name}</div>
                    <div class="solved-category-words">${cat.words.join(', ')}</div>
                `;
                endCategories.appendChild(el);

                setTimeout(() => {
                    el.classList.add('revealed');
                }, i * 150);
            });

            // Show View Leagues button if player has leagues
            const viewLeaguesBtn = document.getElementById('viewLeaguesBtn');
            if (cachedLeaderboards.length > 0) {
                viewLeaguesBtn.classList.remove('hidden');
            } else {
                viewLeaguesBtn.classList.add('hidden');
            }

            // Start countdown
            updateCountdown();
            setInterval(updateCountdown, 1000);

            setTimeout(() => {
                endScreen.classList.add('visible');
            }, 600);
        }

        function updateCountdown() {
            const ms = getTimeUntilMidnight();
            countdownEl.textContent = formatCountdown(ms);
        }

        function generateShareText() {
            const result = getTodayResult();
            const emoji = result.won ? (result.mistakes === 0 ? 'ðŸ†' : 'âœ…') : 'âŒ';

            let grid = '';
            for (const guess of result.guessHistory) {
                if (guess >= 0) {
                    grid += SHARE_EMOJIS[guess].repeat(4) + '\n';
                } else {
                    grid += 'â¬›â¬›â¬›â¬›\n';
                }
            }
            // Add remaining solved categories if won
            if (result.won && result.guessHistory.length < 4) {
                const remaining = [0, 1, 2, 3].filter(i => !result.guessHistory.includes(i));
                for (const i of remaining) {
                    grid += SHARE_EMOJIS[i].repeat(4) + '\n';
                }
            }

            return `Connections UK #${puzzleNumber} ${emoji}\n\n${grid.trim()}\n\nPlay at: ${window.location.href}`;
        }

        async function handleShare() {
            const text = generateShareText();

            try {
                await navigator.clipboard.writeText(text);
                showToast('Copied to clipboard');
            } catch {
                showToast('Could not copy');
            }
        }

        function handleShuffle() {
            if (gameOver) return;
            remainingWords = shuffle(remainingWords);
            renderGrid();
        }

        function handleDeselect() {
            selectedWords = [];
            renderGrid();
            updateButtons();
        }

        // ===== MODALS =====
        function openModal(modal) {
            modal.classList.add('visible');
        }

        function closeModal(modal) {
            modal.classList.remove('visible');
        }

        // ===== ARCHIVE =====
        function populateArchive() {
            archiveList.innerHTML = '';
            const stats = getStats();
            const today = getTodayString();

            // Filter puzzles up to today and sort by date descending
            const availablePuzzles = allPuzzles
                .filter(p => p.date <= today)
                .sort((a, b) => b.date.localeCompare(a.date));

            availablePuzzles.forEach((puzzle, index) => {
                const played = stats.played[puzzle.date];
                const puzzleNum = allPuzzles.findIndex(p => p.date === puzzle.date) + 1;

                const item = document.createElement('div');
                item.className = `archive-item ${played ? 'played' : ''}`;
                item.dataset.date = puzzle.date;

                let statusHTML = '';
                if (played) {
                    const resultEmojis = played.guessHistory.map(g =>
                        g >= 0 ? SHARE_EMOJIS[g] : 'â¬›'
                    ).join('');
                    statusHTML = `
                        <div class="archive-item-result"><span>${resultEmojis}</span></div>
                        <span class="archive-item-badge ${played.won ? 'won' : 'lost'}">${played.won ? 'Won' : 'Lost'}</span>
                    `;
                } else {
                    statusHTML = `<span class="archive-item-badge play">Play</span>`;
                }

                item.innerHTML = `
                    <div class="archive-item-info">
                        <div class="archive-item-date">${formatDateForDisplay(puzzle.date)}</div>
                        <div class="archive-item-number">Puzzle #${puzzleNum}</div>
                    </div>
                    <div class="archive-item-status">
                        ${statusHTML}
                    </div>
                `;

                if (!played) {
                    item.addEventListener('click', () => {
                        closeModal(archiveModal);
                        loadPuzzle(puzzle.date);
                    });
                }

                archiveList.appendChild(item);
            });
        }

        async function loadPuzzle(date) {
            const puzzle = allPuzzles.find(p => p.date === date);
            if (!puzzle) return;

            // Reset game state
            currentPuzzle = puzzle;
            currentDate = date;
            puzzleNumber = allPuzzles.findIndex(p => p.date === date) + 1;
            remainingWords = [];
            selectedWords = [];
            solvedCategories = [];
            mistakes = 0;
            gameOver = false;
            guessHistory = [];

            // Clear UI
            solvedAreaEl.innerHTML = '';
            endScreen.classList.remove('visible');

            const stats = getStats();
            if (stats.played[date]) {
                // Already played - show results
                await restoreCompletedGame(date);
            } else {
                // Fresh game
                remainingWords = shuffle(puzzle.categories.flatMap(c => c.words));
                loadingEl.classList.add('hidden');
                noPuzzleEl.classList.add('hidden');
                gameAreaEl.classList.remove('hidden');
                shuffleBtn.classList.remove('hidden');

                renderGrid();
                renderMistakes();
                updateButtons();
            }
        }

        // ===== RESTORE GAME =====
        async function restoreCompletedGame(date = null) {
            const targetDate = date || currentDate;
            const stats = getStats();
            const result = stats.played[targetDate];
            if (!result) return;

            // Restore all solved categories
            for (let i = 0; i < currentPuzzle.categories.length; i++) {
                const cat = currentPuzzle.categories[i];
                solvedCategories.push(cat);
                renderSolvedCategory(cat);
            }
            remainingWords = [];
            renderGrid();

            mistakes = result.mistakes;
            renderMistakes();
            gameOver = true;

            loadingEl.classList.add('hidden');
            gameAreaEl.classList.remove('hidden');

            endMessage.textContent = result.won ? 'Sorted.' : 'Better luck tomorrow.';

            // Fetch leaderboards for restored game
            try {
                await fetchPlayerLeagues();
                cachedLeaderboards = await fetchLeaderboards();
                renderPlayerRankings(cachedLeaderboards);
            } catch (e) {
                console.log('Could not load league data:', e);
            }

            showEndScreen();
        }

        // ===== INIT =====
        async function init() {
            // Event listeners
            submitBtn.addEventListener('click', handleSubmit);
            deselectBtn.addEventListener('click', handleDeselect);
            shuffleBtn.addEventListener('click', handleShuffle);
            shareBtn.addEventListener('click', handleShare);
            rulesBtn.addEventListener('click', () => openModal(rulesModal));
            statsBtn.addEventListener('click', () => {
                updateStatsDisplay();
                openModal(statsModal);
            });
            archiveBtn.addEventListener('click', () => {
                populateArchive();
                openModal(archiveModal);
            });

            // League elements
            const createLeagueForm = document.getElementById('createLeagueForm');
            const createLeagueTitle = document.getElementById('createLeagueTitle');
            const leagueCreatedName = document.getElementById('leagueCreatedName');
            const createAnotherBtn = document.getElementById('createAnotherBtn');
            const viewLeaguesBtn = document.getElementById('viewLeaguesBtn');

            function resetCreateLeagueModal() {
                leagueNameInput.value = '';
                createLeagueForm.classList.remove('hidden');
                leagueUrlContainer.classList.add('hidden');
                createLeagueTitle.textContent = 'Create a League';
            }

            // League event listeners
            createLeagueBtn.addEventListener('click', () => {
                resetCreateLeagueModal();
                openModal(createLeagueModal);
            });

            createAnotherBtn.addEventListener('click', () => {
                resetCreateLeagueModal();
            });

            viewLeaguesBtn.addEventListener('click', () => {
                if (cachedLeaderboards.length > 0) {
                    renderLeagueModal(0);
                    openModal(document.getElementById('viewLeaguesModal'));
                }
            });

            document.getElementById('prevLeagueBtn').addEventListener('click', () => {
                if (currentLeagueIndex > 0) {
                    renderLeagueModal(currentLeagueIndex - 1);
                }
            });

            document.getElementById('nextLeagueBtn').addEventListener('click', () => {
                if (currentLeagueIndex < cachedLeaderboards.length - 1) {
                    renderLeagueModal(currentLeagueIndex + 1);
                }
            });

            createLeagueSubmit.addEventListener('click', async () => {
                const name = leagueNameInput.value.trim();
                if (!name) return;

                createLeagueSubmit.disabled = true;
                try {
                    // Ensure we have a name before creating
                    if (!playerName) {
                        pendingLeagueId = null; // Will create after name entry
                        const tempName = name; // Store league name
                        closeModal(createLeagueModal);

                        // Prompt for player name
                        joinLeagueName.textContent = tempName;
                        playerNameInput.value = '';

                        // Special handling: create league after name entry
                        pendingLeagueId = 'CREATE:' + tempName;
                        openModal(joinLeagueModal);
                        return;
                    }

                    const league = await createLeague(name);
                    leagueUrlInput.value = league.url;
                    leagueCreatedName.textContent = `"${name}" created!`;
                    createLeagueForm.classList.add('hidden');
                    leagueUrlContainer.classList.remove('hidden');
                    createLeagueTitle.textContent = 'League Created';
                    await renderLeagueWidget();
                } catch (error) {
                    showToast('Failed to create league');
                } finally {
                    createLeagueSubmit.disabled = false;
                }
            });

            copyLeagueUrl.addEventListener('click', async () => {
                try {
                    await navigator.clipboard.writeText(leagueUrlInput.value);
                    showToast('Link copied!');
                } catch {
                    showToast('Could not copy');
                }
            });

            joinLeagueSubmit.addEventListener('click', async () => {
                const name = playerNameInput.value.trim();
                if (!name) return;

                joinLeagueSubmit.disabled = true;
                try {
                    setPlayerName(name);
                    ensurePlayerUUID();

                    // Update player name in Supabase
                    await db
                        .from('players')
                        .upsert({ uuid: playerUUID, display_name: name.trim() }, { onConflict: 'uuid' });

                    if (pendingLeagueId) {
                        if (pendingLeagueId.startsWith('CREATE:')) {
                            // Was creating a league, now create it
                            const leagueName = pendingLeagueId.slice(7);
                            const league = await createLeague(leagueName);
                            closeModal(joinLeagueModal);
                            openModal(createLeagueModal);
                            leagueUrlInput.value = league.url;
                            leagueCreatedName.textContent = `"${leagueName}" created!`;
                            createLeagueForm.classList.add('hidden');
                            leagueUrlContainer.classList.remove('hidden');
                            createLeagueTitle.textContent = 'League Created';
                        } else {
                            // Joining existing league
                            await joinLeague(pendingLeagueId);
                            closeModal(joinLeagueModal);
                            showToast('Joined league!');
                        }
                        pendingLeagueId = null;
                    }

                    await renderLeagueWidget();
                } catch (error) {
                    showToast('Failed to join');
                } finally {
                    joinLeagueSubmit.disabled = false;
                }
            });

            // Modal close buttons
            document.querySelectorAll('.modal-close').forEach(btn => {
                btn.addEventListener('click', () => {
                    closeModal(btn.closest('.modal-overlay'));
                });
            });

            // Click outside modal to close (but not for join modal - must complete)
            document.querySelectorAll('.modal-overlay').forEach(overlay => {
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay && overlay.id !== 'joinLeagueModal') {
                        closeModal(overlay);
                    }
                });
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    document.querySelectorAll('.modal-overlay.visible').forEach(modal => {
                        if (modal.id !== 'joinLeagueModal') {
                            closeModal(modal);
                        }
                    });
                }
                if (e.key === 'Enter' && selectedWords.length === 4 && !gameOver) {
                    handleSubmit();
                }
            });

            updateStatsDisplay();

            // Fetch and load puzzle FIRST (don't wait for Supabase)
            allPuzzles = await fetchPuzzles();
            const today = getTodayString();
            currentDate = today;
            const todayPuzzle = allPuzzles.find(p => p.date === today);

            if (!todayPuzzle) {
                loadingEl.classList.add('hidden');
                noPuzzleEl.classList.remove('hidden');
                shuffleBtn.classList.add('hidden');
                return;
            }

            currentPuzzle = todayPuzzle;
            puzzleNumber = allPuzzles.findIndex(p => p.date === today) + 1;

            // Check if already played
            const stats = getStats();
            if (stats.played[today]) {
                loadingEl.classList.add('hidden');
                gameAreaEl.classList.remove('hidden');
                restoreCompletedGame(today);
                return;
            }

            // Start fresh game
            remainingWords = shuffle(currentPuzzle.categories.flatMap(c => c.words));

            loadingEl.classList.add('hidden');
            gameAreaEl.classList.remove('hidden');

            renderGrid();
            renderMistakes();
            updateButtons();

            // Load league features in background (don't block game)
            setTimeout(async () => {
                try {
                    await checkLeagueUrl();
                    await renderLeagueWidget();
                } catch (e) {
                    console.log('League features unavailable:', e);
                }
            }, 100);
        }

        init();
    </script>
</body>
</html>
