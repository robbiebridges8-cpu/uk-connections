<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Connections UK</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap');

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --bg-primary: #1a1a1a;
            --bg-secondary: #242424;
            --bg-tile: rgba(255, 255, 255, 0.06);
            --bg-tile-hover: rgba(255, 255, 255, 0.1);
            --bg-tile-selected: rgba(255, 255, 255, 0.15);
            --border-tile: rgba(255, 255, 255, 0.1);
            --border-selected: rgba(255, 255, 255, 0.4);
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.6);
            --text-muted: rgba(255, 255, 255, 0.4);

            /* Category colors */
            --category-1: #F5D800;  /* Easiest - yellow */
            --category-2: #6CC66C;  /* Easy - green */
            --category-3: #36DFE7;  /* Hard - cyan */
            --category-4: #7E4E7E;  /* Hardest - purple */
            --category-text-light: #1a1a1a;  /* Dark text for light backgrounds */
            --category-text-dark: #ffffff;   /* Light text for dark backgrounds */
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            min-height: 100dvh;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow-x: hidden;
        }

        /* Noise texture overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.03;
            pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            z-index: 0;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            position: relative;
            z-index: 10;
        }

        .logo-section {
            display: flex;
            flex-direction: column;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 800;
            letter-spacing: 0.15em;
            color: var(--text-primary);
        }

        .tagline {
            font-size: 0.7rem;
            color: var(--text-muted);
            font-weight: 400;
            margin-top: 2px;
        }

        .header-actions {
            display: flex;
            gap: 8px;
        }

        .header-btn {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
            font-size: 0.75rem;
            font-weight: 500;
            letter-spacing: 0.02em;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 20px;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .header-btn:hover {
            color: var(--text-primary);
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.2);
        }

        /* Main container */
        .container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 20px 20px;
            position: relative;
            z-index: 1;
            max-width: 520px;
            margin: 0 auto;
            width: 100%;
        }

        /* Mistakes indicator */
        .mistakes-container {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            height: 24px;
            align-items: center;
        }

        .mistake-pip {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--text-secondary);
            transition: all 0.3s ease;
        }

        .mistake-pip.used {
            background: rgba(255, 255, 255, 0.15);
            transform: scale(0.7);
        }

        /* Difficulty legend */
        .difficulty-legend {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            margin-bottom: 16px;
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .difficulty-label {
            font-weight: 500;
        }

        .difficulty-swatches {
            display: flex;
            gap: 4px;
        }

        .difficulty-swatch {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        .difficulty-swatch.swatch-1 { background: var(--category-1); }
        .difficulty-swatch.swatch-2 { background: var(--category-2); }
        .difficulty-swatch.swatch-3 { background: var(--category-3); }
        .difficulty-swatch.swatch-4 { background: var(--category-4); }

        /* Solved categories area */
        .solved-area {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 8px;
        }

        .solved-category {
            border-radius: 12px;
            padding: 16px 20px;
            text-align: center;
            opacity: 0;
            transform: scale(0.9);
            animation: solvedReveal 0.5s ease forwards;
        }

        .solved-category.gradient-1 { background: var(--category-1); color: var(--category-text-light); }
        .solved-category.gradient-2 { background: var(--category-2); color: var(--category-text-light); }
        .solved-category.gradient-3 { background: var(--category-3); color: var(--category-text-light); }
        .solved-category.gradient-4 { background: var(--category-4); color: var(--category-text-dark); }

        @keyframes solvedReveal {
            0% {
                opacity: 0;
                transform: scale(0.9);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        .solved-category-name {
            font-size: 0.85rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            margin-bottom: 6px;
            text-transform: uppercase;
            color: inherit;
            overflow: visible;
        }

        .solved-category-name span {
            display: inline-block;
            white-space: nowrap;
            transform-origin: left center;
        }

        .solved-category-words {
            font-size: 0.8rem;
            font-weight: 400;
            opacity: 0.85;
            letter-spacing: 0.02em;
            color: inherit;
            overflow: visible;
        }

        .solved-category-words span {
            display: inline-block;
            white-space: nowrap;
            transform-origin: left center;
        }

        /* Grid */
        .grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            width: 100%;
            margin-bottom: 20px;
        }

        .tile {
            aspect-ratio: 1.2;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px 4px;
            border-radius: 12px;
            background: var(--bg-tile);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border-tile);
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 700;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            text-align: center;
            white-space: nowrap;
            transition: all 0.2s ease;
            user-select: none;
            position: relative;
            color: #ffffff;
            overflow: hidden;
        }

        .tile span {
            display: block;
            white-space: nowrap;
            transform-origin: center;
        }

        .tile:hover {
            background: var(--bg-tile-hover);
            transform: scale(1.02);
        }

        .tile:active {
            transform: scale(0.98);
        }

        .tile.selected {
            background: var(--bg-tile-selected);
            border-color: var(--border-selected);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1),
                        inset 0 0 20px rgba(255, 255, 255, 0.05);
            animation: selectedPulse 2s ease-in-out infinite;
        }

        @keyframes selectedPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 255, 255, 0.1), inset 0 0 20px rgba(255, 255, 255, 0.05); }
            50% { box-shadow: 0 0 30px rgba(255, 255, 255, 0.2), inset 0 0 25px rgba(255, 255, 255, 0.08); }
        }

        .tile.shake {
            animation: shake 0.5s ease;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-8px); }
            40% { transform: translateX(8px); }
            60% { transform: translateX(-6px); }
            80% { transform: translateX(6px); }
        }

        .tile.solving {
            animation: tileCollapse 0.4s ease forwards;
        }

        @keyframes tileCollapse {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(0.5);
            }
        }

        /* Buttons area */
        .buttons-area {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: auto;
            padding-top: 20px;
            width: 100%;
        }

        .btn {
            padding: 14px 32px;
            border-radius: 100px;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
        }

        .btn-primary {
            background: var(--text-primary);
            color: var(--bg-primary);
        }

        .btn-primary:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 20px rgba(255, 255, 255, 0.2);
        }

        .btn-primary:active {
            transform: scale(0.98);
        }

        .btn-primary:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            border-color: rgba(255, 255, 255, 0.4);
            color: var(--text-primary);
        }

        .submit-btn {
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .submit-btn.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        /* Toast */
        .toast-container {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            pointer-events: none;
        }

        .toast {
            background: rgba(255, 255, 255, 0.95);
            color: var(--bg-primary);
            padding: 12px 24px;
            border-radius: 100px;
            font-weight: 600;
            font-size: 0.9rem;
            animation: toastIn 0.3s ease, toastOut 0.3s ease 1.5s forwards;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        @keyframes toastIn {
            from { opacity: 0; transform: translateY(-20px) scale(0.9); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        @keyframes toastOut {
            from { opacity: 1; transform: translateY(0) scale(1); }
            to { opacity: 0; transform: translateY(-20px) scale(0.9); }
        }

        /* Particles */
        .particle {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            pointer-events: none;
            animation: particleBurst 0.8s ease-out forwards;
        }

        @keyframes particleBurst {
            0% {
                opacity: 1;
                transform: translate(0, 0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(var(--tx), var(--ty)) scale(0);
            }
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 32px;
            max-width: 400px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            transform: scale(0.9) translateY(20px);
            transition: all 0.3s ease;
            position: relative;
        }

        .modal-overlay.visible .modal {
            transform: scale(1) translateY(0);
        }

        .modal-close {
            position: absolute;
            top: 16px;
            right: 16px;
            background: transparent;
            border: none;
            color: var(--text-muted);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 4px;
            line-height: 1;
        }

        .modal-close:hover {
            color: var(--text-primary);
        }

        .modal h2 {
            font-size: 1.25rem;
            font-weight: 700;
            letter-spacing: 0.05em;
            margin-bottom: 20px;
            text-transform: uppercase;
        }

        .modal p {
            color: var(--text-secondary);
            font-size: 0.95rem;
            line-height: 1.6;
            margin-bottom: 16px;
        }

        .modal p:last-child {
            margin-bottom: 0;
        }

        /* Stats modal */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-bottom: 24px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-top: 4px;
        }

        /* Archive modal */
        .modal-archive {
            max-height: 80vh;
        }

        .archive-subtitle {
            color: var(--text-muted);
            font-size: 0.85rem;
            margin-bottom: 20px;
        }

        .archive-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 400px;
            overflow-y: auto;
            padding-right: 8px;
        }

        .archive-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .archive-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .archive-item.played {
            cursor: default;
        }

        .archive-item-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .archive-item-date {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-primary);
        }

        .archive-item-number {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .archive-item-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .archive-item-result {
            display: flex;
            gap: 2px;
        }

        .archive-item-result span {
            font-size: 0.7rem;
        }

        .archive-item-badge {
            font-size: 0.7rem;
            padding: 4px 10px;
            border-radius: 100px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .archive-item-badge.won {
            background: rgba(108, 198, 108, 0.2);
            color: #6CC66C;
        }

        .archive-item-badge.lost {
            background: rgba(126, 78, 126, 0.3);
            color: #a080a0;
        }

        .archive-item-badge.play {
            background: var(--text-primary);
            color: var(--bg-primary);
        }

        /* League widget */
        .league-widget {
            width: 100%;
            margin-bottom: 20px;
        }

        .league-widget-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .league-widget-title {
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
        }

        .league-widget-create {
            font-size: 0.75rem;
            color: var(--text-muted);
            background: none;
            border: none;
            cursor: pointer;
            text-decoration: underline;
            padding: 0;
        }

        .league-widget-create:hover {
            color: var(--text-primary);
        }

        .league-widget-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .league-widget-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 14px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            font-size: 0.85rem;
        }

        .league-widget-name {
            font-weight: 500;
            color: var(--text-primary);
        }

        .league-widget-count {
            color: var(--text-muted);
            font-size: 0.75rem;
        }

        .league-widget-empty {
            text-align: center;
            padding: 16px;
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        .league-widget-empty a {
            color: var(--text-secondary);
        }

        /* League modal inputs */
        .modal-input {
            width: 100%;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.95rem;
            margin-bottom: 16px;
        }

        .modal-input:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.3);
        }

        .modal-input::placeholder {
            color: var(--text-muted);
        }

        .modal-btn {
            width: 100%;
            padding: 14px;
            background: var(--text-primary);
            color: var(--bg-primary);
            border: none;
            border-radius: 100px;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modal-btn:hover {
            transform: scale(1.02);
        }

        .modal-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .league-url-container {
            margin-top: 16px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .league-url-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .league-url {
            display: flex;
            gap: 8px;
        }

        .league-url input {
            flex: 1;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 6px;
            color: var(--text-primary);
            font-family: monospace;
            font-size: 0.8rem;
        }

        .league-url button {
            padding: 8px 16px;
            background: var(--text-primary);
            color: var(--bg-primary);
            border: none;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
        }

        /* Leaderboard */
        .leaderboard-section {
            width: 100%;
            max-width: 400px;
            margin-top: 24px;
        }

        .leaderboard-title {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-primary);
        }

        .leaderboard-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .leaderboard-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 14px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .leaderboard-item.current-player {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .leaderboard-rank {
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--text-muted);
            min-width: 24px;
        }

        .leaderboard-name {
            flex: 1;
            font-size: 0.85rem;
            color: var(--text-primary);
        }

        .leaderboard-mistakes {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .leaderboard-not-played {
            font-size: 0.75rem;
            color: var(--text-muted);
            font-style: italic;
        }

        .leaderboards-container {
            display: flex;
            flex-direction: column;
            gap: 24px;
            width: 100%;
            max-width: 400px;
            margin-top: 24px;
            max-height: 300px;
            overflow-y: auto;
        }

        /* Player rankings on end screen */
        .player-rankings {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
            max-width: 350px;
            margin-bottom: 20px;
        }

        .player-rank-card {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .player-rank-league {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .player-rank-position {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .player-rank-position strong {
            color: var(--text-primary);
            font-weight: 700;
        }

        /* League modal navigation */
        .league-nav {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            margin-bottom: 8px;
        }

        .league-nav h2 {
            flex: 1;
            text-align: center;
            margin: 0;
            font-size: 1.1rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .league-nav-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: var(--text-primary);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .league-nav-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .league-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .league-indicator {
            text-align: center;
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 16px;
        }

        #leagueModalLeaderboard {
            max-height: 350px;
            overflow-y: auto;
        }

        /* End screen */
        .end-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            z-index: 1500;
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s ease;
        }

        .end-screen.visible {
            opacity: 1;
            visibility: visible;
        }

        .end-message {
            font-size: 1.75rem;
            font-weight: 700;
            letter-spacing: 0.05em;
            margin-bottom: 32px;
            text-align: center;
        }

        .end-categories {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
            max-width: 400px;
            margin-bottom: 32px;
        }

        .end-category {
            border-radius: 12px;
            padding: 14px 18px;
            text-align: center;
            opacity: 0;
            transform: translateY(20px);
        }

        .end-category.revealed {
            animation: categoryReveal 0.5s ease forwards;
        }

        @keyframes categoryReveal {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .countdown-section {
            text-align: center;
            margin-top: 24px;
        }

        .countdown-label {
            font-size: 0.8rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 8px;
        }

        .countdown-time {
            font-size: 1.5rem;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        /* Loading state */
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 300px;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--text-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 16px;
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        /* No puzzle state */
        .no-puzzle {
            text-align: center;
            padding: 60px 20px;
        }

        .no-puzzle h2 {
            font-size: 1.25rem;
            margin-bottom: 12px;
        }

        .no-puzzle p {
            color: var(--text-secondary);
        }

        /* Hidden utility */
        .hidden {
            display: none !important;
        }

        /* Responsive */
        @media (max-width: 480px) {
            .header {
                padding: 12px 16px;
            }

            .logo {
                font-size: 1.25rem;
            }

            .container {
                padding: 0 12px 12px;
            }

            .grid {
                gap: 6px;
            }

            .tile {
                font-size: 0.65rem;
                border-radius: 10px;
                padding: 6px;
            }

            .solved-category {
                padding: 12px 16px;
            }

            .solved-category-name {
                font-size: 0.75rem;
            }

            .solved-category-words {
                font-size: 0.7rem;
            }

            .btn {
                padding: 12px 24px;
                font-size: 0.85rem;
            }
        }

        @media (max-width: 360px) {
            .tile {
                font-size: 0.6rem;
                letter-spacing: 0.04em;
            }

            .buttons-area {
                flex-direction: column;
                gap: 8px;
            }

            .btn {
                width: 100%;
            }
        }

        /* Landscape phones */
        @media (max-height: 500px) and (orientation: landscape) {
            .container {
                padding-top: 8px;
            }

            .mistakes-container {
                margin-bottom: 12px;
            }

            .tile {
                aspect-ratio: 1.5;
            }

            .buttons-area {
                padding-top: 12px;
            }
        }

        /* Auth prompt on end screen */
        .auth-prompt {
            width: 100%;
            max-width: 350px;
            margin-bottom: 24px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
        }

        .auth-prompt.hidden {
            display: none;
        }

        .auth-prompt-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .auth-prompt-subtitle {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-bottom: 16px;
        }

        .auth-prompt-form {
            display: flex;
            gap: 8px;
        }

        .auth-prompt-input {
            flex: 1;
            padding: 10px 14px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.85rem;
        }

        .auth-prompt-input:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.3);
        }

        .auth-prompt-input::placeholder {
            color: var(--text-muted);
        }

        .auth-prompt-btn {
            padding: 10px 16px;
            background: var(--text-primary);
            color: var(--bg-primary);
            border: none;
            border-radius: 8px;
            font-family: inherit;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s ease;
        }

        .auth-prompt-btn:hover {
            transform: scale(1.02);
        }

        .auth-prompt-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .auth-prompt-success {
            font-size: 0.85rem;
            color: #6CC66C;
            padding: 12px;
        }

        .auth-prompt-error {
            font-size: 0.8rem;
            color: #ff6b6b;
            margin-top: 8px;
        }

        .auth-status {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 12px;
        }

        .auth-status a {
            color: var(--text-secondary);
            cursor: pointer;
        }

        .auth-status a:hover {
            color: var(--text-primary);
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo-section">
            <div class="logo">CONNECTIONS UK</div>
            <div class="tagline">The game you know and love, without the Americanisms.</div>
        </div>
        <div class="header-actions">
            <button class="header-btn" id="archiveBtn" aria-label="Archive">Past Puzzles</button>
            <button class="header-btn" id="rulesBtn" aria-label="How to play">How to Play</button>
            <button class="header-btn" id="statsBtn" aria-label="Statistics">Stats</button>
        </div>
    </header>

    <main class="container">
        <!-- Loading state -->
        <div class="loading" id="loading">
            <div class="loading-spinner"></div>
            <div class="loading-text">Loading puzzle...</div>
        </div>

        <!-- No puzzle state -->
        <div class="no-puzzle hidden" id="noPuzzle">
            <h2>No puzzle today</h2>
            <p>Check back tomorrow for a new challenge.</p>
        </div>

        <!-- League widget -->
        <div class="league-widget hidden" id="leagueWidget">
            <div class="league-widget-header">
                <span class="league-widget-title">Your Leagues</span>
                <button class="league-widget-create" id="createLeagueBtn">+ Create League</button>
            </div>
            <div class="league-widget-list" id="leagueWidgetList">
                <!-- Populated by JavaScript -->
            </div>
        </div>

        <!-- Game area -->
        <div class="game-area hidden" id="gameArea">
            <div class="mistakes-container" id="mistakes">
                <div class="mistake-pip"></div>
                <div class="mistake-pip"></div>
                <div class="mistake-pip"></div>
                <div class="mistake-pip"></div>
            </div>

            <div class="difficulty-legend">
                <span class="difficulty-label">Easy</span>
                <div class="difficulty-swatches">
                    <div class="difficulty-swatch swatch-1"></div>
                    <div class="difficulty-swatch swatch-2"></div>
                    <div class="difficulty-swatch swatch-3"></div>
                    <div class="difficulty-swatch swatch-4"></div>
                </div>
                <span class="difficulty-label">Hard</span>
            </div>

            <div class="solved-area" id="solvedArea"></div>

            <div class="grid" id="grid"></div>

            <div class="buttons-area">
                <button class="btn btn-secondary" id="shuffleBtn">Shuffle</button>
                <button class="btn btn-secondary" id="deselectBtn">Deselect All</button>
                <button class="btn btn-primary submit-btn" id="submitBtn" disabled>Submit</button>
            </div>
        </div>
    </main>

    <!-- Toast container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Rules Modal -->
    <div class="modal-overlay" id="rulesModal">
        <div class="modal">
            <button class="modal-close" aria-label="Close">&times;</button>
            <h2>How to Play</h2>
            <p>Sixteen words. Four groups. Sounds simple. It isn't.</p>
            <p>Find the connections &mdash; but watch out, some words are deliberately misleading. You've got four mistakes before it's all over.</p>
            <p>Tap four words you think belong together, then hit Submit. If you're right, they'll disappear and reveal their connection. If you're wrong, you'll lose a life.</p>
            <p>The colours indicate difficulty, Met Office style: green is the friendliest, red is... well, you've been warned.</p>
        </div>
    </div>

    <!-- Stats Modal -->
    <div class="modal-overlay" id="statsModal">
        <div class="modal">
            <button class="modal-close" aria-label="Close">&times;</button>
            <h2>Statistics</h2>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="statPlayed">0</div>
                    <div class="stat-label">Played</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="statWinRate">0%</div>
                    <div class="stat-label">Win %</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="statStreak">0</div>
                    <div class="stat-label">Streak</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Archive Modal -->
    <div class="modal-overlay" id="archiveModal">
        <div class="modal modal-archive">
            <button class="modal-close" aria-label="Close">&times;</button>
            <h2>Archive</h2>
            <p class="archive-subtitle">Play puzzles you've missed or revisit your results.</p>
            <div class="archive-list" id="archiveList">
                <!-- Populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Create League Modal -->
    <div class="modal-overlay" id="createLeagueModal">
        <div class="modal">
            <button class="modal-close" aria-label="Close">&times;</button>
            <h2 id="createLeagueTitle">Create a League</h2>
            <div id="createLeagueForm">
                <p>Start a league and invite your mates to compete daily.</p>
                <input type="text" class="modal-input" id="leagueNameInput" placeholder="League name (e.g. Flat 4)" maxlength="50">
                <button class="modal-btn" id="createLeagueSubmit">Create League</button>
            </div>
            <div class="league-url-container hidden" id="leagueUrlContainer">
                <p id="leagueCreatedName" style="margin-bottom: 12px; font-weight: 600;"></p>
                <div class="league-url-label">Share this link with your mates</div>
                <div class="league-url">
                    <input type="text" id="leagueUrlInput" readonly>
                    <button id="copyLeagueUrl">Copy</button>
                </div>
                <button class="modal-btn" id="createAnotherBtn" style="margin-top: 16px; background: transparent; border: 1px solid rgba(255,255,255,0.2); color: var(--text-secondary);">Create Another League</button>
            </div>
        </div>
    </div>

    <!-- Join League Modal (Name Prompt) -->
    <div class="modal-overlay" id="joinLeagueModal">
        <div class="modal">
            <h2>Join <span id="joinLeagueName"></span></h2>
            <p>Enter your display name to join this league.</p>
            <input type="text" class="modal-input" id="playerNameInput" placeholder="Your name" maxlength="30">
            <button class="modal-btn" id="joinLeagueSubmit">Join League</button>
        </div>
    </div>

    <!-- Auth Required Modal (for league actions) -->
    <div class="modal-overlay" id="authRequiredModal">
        <div class="modal">
            <button class="modal-close" aria-label="Close">&times;</button>
            <h2>Sign in to Continue</h2>
            <p>Enter your email to create or join leagues. We'll send you a magic link - no password needed.</p>
            <input type="email" class="modal-input" id="authModalEmail" placeholder="your@email.com">
            <button class="modal-btn" id="authModalSubmit">Send Magic Link</button>
            <div class="auth-prompt-success hidden" id="authModalSuccess" style="text-align: center; margin-top: 16px;">Check your email for the magic link!</div>
            <div class="auth-prompt-error hidden" id="authModalError" style="text-align: center; margin-top: 8px;"></div>
        </div>
    </div>

    <!-- Welcome Modal (after auth, set display name) -->
    <div class="modal-overlay" id="welcomeModal">
        <div class="modal">
            <h2>Welcome!</h2>
            <p>You're signed in. Set your display name to compete in leagues with friends.</p>
            <input type="text" class="modal-input" id="welcomeNameInput" placeholder="Your display name" maxlength="30">
            <button class="modal-btn" id="welcomeSubmit">Continue</button>
        </div>
    </div>

    <!-- End Screen -->
    <div class="end-screen" id="endScreen">
        <div class="end-message" id="endMessage">Sorted.</div>
        <div class="end-categories" id="endCategories"></div>

        <!-- Auth prompt for anonymous users -->
        <div class="auth-prompt hidden" id="authPrompt">
            <div class="auth-prompt-title">Save your progress</div>
            <div class="auth-prompt-subtitle">Enter your email to sync stats across devices and join leagues</div>
            <div class="auth-prompt-form" id="authPromptForm">
                <input type="email" class="auth-prompt-input" id="authPromptEmail" placeholder="your@email.com">
                <button class="auth-prompt-btn" id="authPromptBtn">Send Link</button>
            </div>
            <div class="auth-prompt-success hidden" id="authPromptSuccess">Check your email for the magic link!</div>
            <div class="auth-prompt-error hidden" id="authPromptError"></div>
            <div class="auth-status hidden" id="authStatus">
                Signed in as <span id="authEmail"></span> Â· <a id="signOutBtn">Sign out</a>
            </div>
        </div>

        <div class="player-rankings hidden" id="playerRankings">
            <!-- Shows player's rank in each league -->
        </div>
        <div class="buttons-area">
            <button class="btn btn-secondary hidden" id="viewLeaguesBtn">View Leagues</button>
            <button class="btn btn-primary" id="shareBtn">Share Result</button>
        </div>
        <div class="countdown-section">
            <div class="countdown-label">Next puzzle in</div>
            <div class="countdown-time" id="countdown">--:--:--</div>
        </div>
    </div>

    <!-- View Leagues Modal -->
    <div class="modal-overlay" id="viewLeaguesModal">
        <div class="modal" style="max-width: 450px;">
            <button class="modal-close" aria-label="Close" style="top: 12px; right: 12px;">&times;</button>
            <div class="league-nav" style="margin-top: 16px;">
                <button class="league-nav-btn" id="prevLeagueBtn">&larr;</button>
                <h2 id="leagueModalTitle">League Name</h2>
                <button class="league-nav-btn" id="nextLeagueBtn">&rarr;</button>
            </div>
            <div class="league-indicator" id="leagueIndicator">1 / 3</div>
            <div class="leaderboard-list" id="leagueModalLeaderboard">
                <!-- Populated by JavaScript -->
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // ===== CONFIGURATION =====
        const GRADIENT_CLASSES = ['gradient-1', 'gradient-2', 'gradient-3', 'gradient-4'];
        const PUZZLE_CACHE_KEY = 'cached-puzzle';
        const SHARE_EMOJIS = ['ðŸŸ¨', 'ðŸŸ©', 'ðŸŸ¦', 'ðŸŸª']; // Yellow, green, blue, purple

        // Supabase configuration (placeholders replaced at build time by Netlify)
        const SUPABASE_URL = 'NETLIFY_SUPABASE_URL';
        const SUPABASE_ANON_KEY = 'NETLIFY_SUPABASE_ANON_KEY';
        const db = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // ===== STATE =====
        let currentPuzzle = null;
        let currentDate = null; // The date of the puzzle being played
        let remainingWords = [];
        let selectedWords = [];
        let solvedCategories = [];
        let mistakes = 0;
        let gameOver = false;
        let guessHistory = [];
        let puzzleNumber = 1;

        // ===== DOM ELEMENTS =====
        const loadingEl = document.getElementById('loading');
        const noPuzzleEl = document.getElementById('noPuzzle');
        const gameAreaEl = document.getElementById('gameArea');
        const gridEl = document.getElementById('grid');
        const solvedAreaEl = document.getElementById('solvedArea');
        const mistakesEl = document.getElementById('mistakes');
        const submitBtn = document.getElementById('submitBtn');
        const deselectBtn = document.getElementById('deselectBtn');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const rulesBtn = document.getElementById('rulesBtn');
        const statsBtn = document.getElementById('statsBtn');
        const archiveBtn = document.getElementById('archiveBtn');
        const rulesModal = document.getElementById('rulesModal');
        const statsModal = document.getElementById('statsModal');
        const archiveModal = document.getElementById('archiveModal');
        const archiveList = document.getElementById('archiveList');
        const endScreen = document.getElementById('endScreen');
        const endMessage = document.getElementById('endMessage');
        const endCategories = document.getElementById('endCategories');
        const shareBtn = document.getElementById('shareBtn');
        const countdownEl = document.getElementById('countdown');
        const toastContainer = document.getElementById('toastContainer');

        // League elements
        const leagueWidget = document.getElementById('leagueWidget');
        const leagueWidgetList = document.getElementById('leagueWidgetList');
        const createLeagueBtn = document.getElementById('createLeagueBtn');
        const createLeagueModal = document.getElementById('createLeagueModal');
        const leagueNameInput = document.getElementById('leagueNameInput');
        const createLeagueSubmit = document.getElementById('createLeagueSubmit');
        const leagueUrlContainer = document.getElementById('leagueUrlContainer');
        const leagueUrlInput = document.getElementById('leagueUrlInput');
        const copyLeagueUrl = document.getElementById('copyLeagueUrl');
        const joinLeagueModal = document.getElementById('joinLeagueModal');
        const joinLeagueName = document.getElementById('joinLeagueName');
        const playerNameInput = document.getElementById('playerNameInput');
        const joinLeagueSubmit = document.getElementById('joinLeagueSubmit');
        const leaderboardsContainer = document.getElementById('leaderboardsContainer');

        // League state
        let currentUser = null; // Supabase user object
        let playerName = localStorage.getItem('player-name');
        let playerLeagues = [];
        let pendingLeagueId = null; // League to join after name entry
        let pendingAuthAction = null; // Action to perform after auth (e.g., { type: 'create_league' } or { type: 'join_league', leagueId: '...' })

        // Auth elements
        const authPrompt = document.getElementById('authPrompt');
        const authPromptForm = document.getElementById('authPromptForm');
        const authPromptEmail = document.getElementById('authPromptEmail');
        const authPromptBtn = document.getElementById('authPromptBtn');
        const authPromptSuccess = document.getElementById('authPromptSuccess');
        const authPromptError = document.getElementById('authPromptError');
        const authStatus = document.getElementById('authStatus');
        const authEmail = document.getElementById('authEmail');
        const signOutBtn = document.getElementById('signOutBtn');
        const authRequiredModal = document.getElementById('authRequiredModal');
        const authModalEmail = document.getElementById('authModalEmail');
        const authModalSubmit = document.getElementById('authModalSubmit');
        const authModalSuccess = document.getElementById('authModalSuccess');
        const authModalError = document.getElementById('authModalError');
        const welcomeModal = document.getElementById('welcomeModal');
        const welcomeNameInput = document.getElementById('welcomeNameInput');
        const welcomeSubmit = document.getElementById('welcomeSubmit');

        // ===== AUTH FUNCTIONS =====
        function getCurrentUserId() {
            return currentUser?.id || null;
        }

        function isAnonymousUser() {
            return currentUser?.is_anonymous === true;
        }

        function isAuthenticatedUser() {
            return currentUser && !currentUser.is_anonymous;
        }

        async function initAuth() {
            // Handle PKCE code exchange (used when returning from magic link with ?code= param)
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');

            if (code) {
                try {
                    const { data, error } = await db.auth.exchangeCodeForSession(code);
                    if (error) {
                        console.error('Code exchange error:', error);
                    } else {
                        // Clear URL params
                        window.history.replaceState({}, '', window.location.pathname);
                    }
                } catch (e) {
                    console.error('Code exchange exception:', e);
                }
            }

            // Listen for auth state changes
            // This will fire when Supabase processes tokens from the URL (magic link, OAuth, etc.)
            db.auth.onAuthStateChange(async (event, session) => {
                console.log('Auth state changed:', event, session?.user?.id, session?.user?.is_anonymous);

                const wasAnonymous = currentUser?.is_anonymous;
                const wasNull = currentUser === null;
                currentUser = session?.user || null;

                // Update UI based on auth state
                updateAuthUI();

                // Clean up URL after successful authentication (magic link tokens in hash)
                if (event === 'SIGNED_IN' && currentUser && !currentUser.is_anonymous) {
                    if (window.location.hash) {
                        window.history.replaceState({}, '', window.location.pathname);
                    }
                }

                // If user just upgraded from anonymous to authenticated, or just signed in
                if ((wasAnonymous || wasNull) && currentUser && !currentUser.is_anonymous) {
                    console.log('User is now authenticated');
                    await handlePostAuthFlow();
                }
            });

            // Check for existing session
            const { data: { session } } = await db.auth.getSession();
            console.log('Initial session check:', session?.user?.id, session?.user?.is_anonymous);

            if (session?.user) {
                currentUser = session.user;
                updateAuthUI();

                // If authenticated and has pending action, handle it now
                const hasPending = sessionStorage.getItem('pendingAuthAction');
                if (!currentUser.is_anonymous && hasPending) {
                    console.log('Authenticated user with pending action:', hasPending);
                    await handlePostAuthFlow();
                } else if (!currentUser.is_anonymous && playerName) {
                    // Welcome back message for returning authenticated users
                    showToast(`Welcome back, ${playerName}!`);
                }
            } else {
                // No session, sign in anonymously
                console.log('No session, signing in anonymously');
                const { data, error } = await db.auth.signInAnonymously();
                if (error) {
                    console.error('Anonymous auth error:', error);
                } else {
                    currentUser = data.user;
                    updateAuthUI();
                }
            }
        }

        async function handlePostAuthFlow() {
            console.log('handlePostAuthFlow called');

            // Check for pending action from sessionStorage
            const storedAction = sessionStorage.getItem('pendingAuthAction');
            if (storedAction) {
                console.log('Found pending action:', storedAction);
                sessionStorage.removeItem('pendingAuthAction');
                pendingAuthAction = JSON.parse(storedAction);
            }

            // If user doesn't have a display name, show welcome modal
            if (!playerName) {
                console.log('No player name, showing welcome modal');
                const modal = document.getElementById('welcomeModal');
                if (modal) {
                    openModal(modal);
                } else {
                    console.error('Welcome modal not found!');
                    // Fallback: just show a prompt
                    const name = prompt('Welcome! Enter your display name:');
                    if (name) {
                        setPlayerName(name);
                        const userId = getCurrentUserId();
                        if (userId) {
                            await db.from('players').upsert({ uuid: userId, display_name: name }, { onConflict: 'uuid' });
                        }
                        await handlePendingAuthAction();
                    }
                }
            } else {
                // Has display name, handle pending action directly
                console.log('Has player name, handling pending action');
                await handlePendingAuthAction();
            }
        }

        async function handlePendingAuthAction() {
            if (!pendingAuthAction) return;

            const action = pendingAuthAction;
            pendingAuthAction = null;

            console.log('Handling pending action:', action);

            if (action.type === 'create_league') {
                // Reset and open create league modal
                const form = document.getElementById('createLeagueForm');
                const urlContainer = document.getElementById('leagueUrlContainer');
                const title = document.getElementById('createLeagueTitle');
                const nameInput = document.getElementById('leagueNameInput');
                if (nameInput) nameInput.value = '';
                if (form) form.classList.remove('hidden');
                if (urlContainer) urlContainer.classList.add('hidden');
                if (title) title.textContent = 'Create a League';
                openModal(createLeagueModal);
            } else if (action.type === 'join_league' && action.leagueId) {
                await joinLeague(action.leagueId);
            } else if (action.type === 'welcome') {
                // Just signed up, show toast
                showToast('Signed in successfully!');
            }
        }


        function updateAuthUI() {
            if (!authPrompt) return;

            if (isAuthenticatedUser()) {
                // Hide auth prompt entirely for signed-in users
                authPrompt.classList.add('hidden');
            } else {
                // Show email prompt for anonymous users
                authPromptForm.classList.remove('hidden');
                authPromptSuccess.classList.add('hidden');
                authPromptError.classList.add('hidden');
                authStatus.classList.add('hidden');
                authPrompt.classList.remove('hidden');
            }
        }

        async function sendMagicLink(email, isModal = false) {
            const successEl = isModal ? authModalSuccess : authPromptSuccess;
            const errorEl = isModal ? authModalError : authPromptError;
            const btnEl = isModal ? authModalSubmit : authPromptBtn;

            try {
                btnEl.disabled = true;
                btnEl.textContent = 'Sending...';
                errorEl.classList.add('hidden');

                // Store pending action in sessionStorage so it survives page reload
                if (pendingAuthAction) {
                    sessionStorage.setItem('pendingAuthAction', JSON.stringify(pendingAuthAction));
                } else {
                    // If signing up from end screen prompt, set a flag to show welcome
                    sessionStorage.setItem('pendingAuthAction', JSON.stringify({ type: 'welcome' }));
                }

                const { error } = await db.auth.signInWithOtp({
                    email,
                    options: {
                        emailRedirectTo: window.location.origin
                    }
                });

                if (error) throw error;

                // Show success
                if (isModal) {
                    authModalEmail.classList.add('hidden');
                    btnEl.classList.add('hidden');
                } else {
                    authPromptForm.classList.add('hidden');
                }
                successEl.classList.remove('hidden');

            } catch (error) {
                console.error('Magic link error:', error);
                errorEl.textContent = error.message || 'Failed to send magic link';
                errorEl.classList.remove('hidden');
            } finally {
                btnEl.disabled = false;
                btnEl.textContent = 'Send Link';
            }
        }

        async function signOut() {
            try {
                await db.auth.signOut();
                // Sign in anonymously again
                const { data } = await db.auth.signInAnonymously();
                currentUser = data?.user || null;
                playerLeagues = [];
                cachedLeaderboards = [];
                updateAuthUI();
                renderLeagueWidget();
            } catch (error) {
                console.error('Sign out error:', error);
            }
        }

        function requireAuth(action) {
            if (isAuthenticatedUser()) {
                return true; // Already authenticated
            }
            // Store the pending action and show auth modal
            pendingAuthAction = action;
            openModal(authRequiredModal);
            return false;
        }

        // ===== UTILITY FUNCTIONS =====
        function getTodayString() {
            return new Date().toLocaleDateString('en-GB', {
                timeZone: 'Europe/London',
                year: 'numeric',
                month: '2-digit',
                day: '2-digit'
            }).split('/').reverse().join('-');
        }

        function normalizeDate(dateStr) {
            if (!dateStr) return null;

            // Already in YYYY-MM-DD format
            if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                return dateStr;
            }

            // MM/DD/YYYY format
            if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(dateStr)) {
                const parts = dateStr.split('/');
                const month = parts[0].padStart(2, '0');
                const day = parts[1].padStart(2, '0');
                const year = parts[2];
                return `${year}-${month}-${day}`;
            }

            // DD/MM/YYYY format (British)
            if (/^\d{1,2}-\d{1,2}-\d{4}$/.test(dateStr)) {
                const parts = dateStr.split('-');
                const day = parts[0].padStart(2, '0');
                const month = parts[1].padStart(2, '0');
                const year = parts[2];
                return `${year}-${month}-${day}`;
            }

            // Excel serial date number
            if (!isNaN(dateStr) && Number(dateStr) > 40000) {
                const excelDate = new Date((Number(dateStr) - 25569) * 86400 * 1000);
                const year = excelDate.getFullYear();
                const month = String(excelDate.getMonth() + 1).padStart(2, '0');
                const day = String(excelDate.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            }

            return null;
        }

        function shuffle(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function formatDateForDisplay(dateStr) {
            const date = new Date(dateStr + 'T00:00:00');
            return date.toLocaleDateString('en-GB', {
                day: 'numeric',
                month: 'long',
                year: 'numeric'
            });
        }

        function getTimeUntilMidnight() {
            const now = new Date();
            const midnight = new Date(now);
            midnight.setHours(24, 0, 0, 0);
            return midnight - now;
        }

        function formatCountdown(ms) {
            const hours = Math.floor(ms / (1000 * 60 * 60));
            const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((ms % (1000 * 60)) / 1000);
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        // ===== TOAST =====
        function showToast(message) {
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            toastContainer.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        }

        // ===== PARTICLES =====
        function createParticles(x, y, color) {
            for (let i = 0; i < 12; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;
                particle.style.background = color;

                const angle = (i / 12) * Math.PI * 2;
                const distance = 40 + Math.random() * 40;
                particle.style.setProperty('--tx', `${Math.cos(angle) * distance}px`);
                particle.style.setProperty('--ty', `${Math.sin(angle) * distance}px`);

                document.body.appendChild(particle);
                setTimeout(() => particle.remove(), 800);
            }
        }

        // ===== STATS =====
        function getStats() {
            const stored = localStorage.getItem('linked-stats');
            return stored ? JSON.parse(stored) : {
                played: {},
                streak: 0,
                maxStreak: 0
            };
        }

        function saveStats(stats) {
            localStorage.setItem('linked-stats', JSON.stringify(stats));
        }

        function updateStatsDisplay() {
            const stats = getStats();
            const playedCount = Object.keys(stats.played).length;
            const wins = Object.values(stats.played).filter(p => p.won).length;
            const winRate = playedCount > 0 ? Math.round((wins / playedCount) * 100) : 0;

            document.getElementById('statPlayed').textContent = playedCount;
            document.getElementById('statWinRate').textContent = `${winRate}%`;
            document.getElementById('statStreak').textContent = stats.streak;
        }

        function hasPlayedToday() {
            const stats = getStats();
            return stats.played[getTodayString()] !== undefined;
        }

        function getTodayResult() {
            const stats = getStats();
            return stats.played[getTodayString()];
        }

        // ===== PLAYER/LEAGUE MANAGEMENT =====
        function setPlayerName(name) {
            playerName = name;
            localStorage.setItem('player-name', name);
        }

        async function fetchPlayerLeagues() {
            const userId = getCurrentUserId();
            console.log('fetchPlayerLeagues called, userId:', userId);
            if (!userId) return [];
            try {
                const today = getTodayString();

                // Get all leagues the player is in
                const { data: memberships, error } = await db
                    .from('league_memberships')
                    .select('league_id, leagues(id, name)')
                    .eq('player_uuid', userId);

                console.log('Memberships query result:', { memberships, error });

                if (!memberships || memberships.length === 0) {
                    playerLeagues = [];
                    return [];
                }

                // Get stats for each league
                const leagues = await Promise.all(memberships.map(async m => {
                    const { count: totalMembers } = await db
                        .from('league_memberships')
                        .select('*', { count: 'exact', head: true })
                        .eq('league_id', m.league_id);

                    const { count: playedToday } = await db
                        .from('daily_scores')
                        .select('*', { count: 'exact', head: true })
                        .eq('league_id', m.league_id)
                        .eq('date', today);

                    return {
                        id: m.league_id,
                        name: m.leagues?.name || 'Unknown',
                        total_members: totalMembers || 0,
                        played_today: playedToday || 0
                    };
                }));

                playerLeagues = leagues;
                return playerLeagues;
            } catch (error) {
                console.error('Error fetching leagues:', error);
                return [];
            }
        }

        async function renderLeagueWidget() {
            const leagues = await fetchPlayerLeagues();

            if (leagues.length === 0) {
                leagueWidgetList.innerHTML = `
                    <div class="league-widget-empty">
                        No leagues yet. <a href="#" id="createLeagueLink">Create one</a> or join via a shared link.
                    </div>
                `;
                const createLink = document.getElementById('createLeagueLink');
                if (createLink) {
                    createLink.addEventListener('click', (e) => {
                        e.preventDefault();
                        openModal(createLeagueModal);
                    });
                }
            } else {
                leagueWidgetList.innerHTML = leagues.map(league => `
                    <div class="league-widget-item">
                        <span class="league-widget-name">${league.name}</span>
                        <span class="league-widget-count">${league.played_today}/${league.total_members} played today</span>
                    </div>
                `).join('');
            }

            leagueWidget.classList.remove('hidden');
        }

        async function createLeague(name) {
            const userId = getCurrentUserId();
            if (!userId) return null;

            try {
                // Generate a short ID
                const id = crypto.randomUUID().slice(0, 8);

                const { error } = await db
                    .from('leagues')
                    .insert({ id, name: name.trim() });

                if (error) throw error;

                // Auto-join the league we created
                if (playerName) {
                    await joinLeague(id);
                }

                const url = `${window.location.origin}/league/${id}`;
                return { id, name: name.trim(), url };
            } catch (error) {
                console.error('Error creating league:', error);
                throw error;
            }
        }

        async function joinLeague(leagueId) {
            const userId = getCurrentUserId();
            if (!userId) return false;

            if (!playerName) {
                // Need to prompt for name first
                pendingLeagueId = leagueId;
                const { data: league } = await db
                    .from('leagues')
                    .select('*')
                    .eq('id', leagueId)
                    .single();
                joinLeagueName.textContent = league?.name || 'League';
                openModal(joinLeagueModal);
                return false;
            }

            try {
                // Upsert player
                await db
                    .from('players')
                    .upsert({ uuid: userId, display_name: playerName.trim() }, { onConflict: 'uuid' });

                // Add membership if not exists
                await db
                    .from('league_memberships')
                    .upsert({ player_uuid: userId, league_id: leagueId }, { onConflict: 'player_uuid,league_id', ignoreDuplicates: true });

                await fetchPlayerLeagues();
                return true;
            } catch (error) {
                console.error('Error joining league:', error);
                throw error;
            }
        }

        async function submitScore(mistakeCount) {
            const userId = getCurrentUserId();
            if (!userId || playerLeagues.length === 0) return;

            try {
                // Insert/update score for each league the player is in
                for (const league of playerLeagues) {
                    await db
                        .from('daily_scores')
                        .upsert(
                            { player_uuid: userId, league_id: league.id, date: currentDate, mistakes: mistakeCount },
                            { onConflict: 'player_uuid,league_id,date' }
                        );
                }
            } catch (error) {
                console.error('Error submitting score:', error);
            }
        }

        async function fetchLeaderboards() {
            if (playerLeagues.length === 0) return [];

            const leaderboards = [];
            for (const league of playerLeagues) {
                try {
                    // Get all members with their player info
                    const { data: memberships } = await db
                        .from('league_memberships')
                        .select('player_uuid, players(uuid, display_name)')
                        .eq('league_id', league.id);

                    // Get scores for this date
                    const { data: scores } = await db
                        .from('daily_scores')
                        .select('*')
                        .eq('league_id', league.id)
                        .eq('date', currentDate);

                    // Build member list with scores
                    const members = (memberships || []).map(m => {
                        const score = (scores || []).find(s => s.player_uuid === m.player_uuid);
                        return {
                            uuid: m.player_uuid,
                            display_name: m.players?.display_name || 'Unknown',
                            mistakes: score?.mistakes ?? null,
                            date: score?.date ?? null
                        };
                    });

                    // Sort: played first (by mistakes), then not played (alphabetically)
                    members.sort((a, b) => {
                        if (a.mistakes !== null && b.mistakes !== null) {
                            return a.mistakes - b.mistakes;
                        }
                        if (a.mistakes !== null) return -1;
                        if (b.mistakes !== null) return 1;
                        return a.display_name.localeCompare(b.display_name);
                    });

                    // Calculate ranks
                    let currentRank = 0;
                    let lastMistakes = null;
                    let playedCount = 0;

                    const leaderboard = members.map((member) => {
                        if (member.mistakes !== null) {
                            playedCount++;
                            if (member.mistakes !== lastMistakes) {
                                currentRank = playedCount;
                                lastMistakes = member.mistakes;
                            }
                            return { ...member, rank: currentRank };
                        }
                        return { ...member, rank: null };
                    });

                    leaderboards.push({
                        league: { id: league.id, name: league.name },
                        date: currentDate,
                        leaderboard
                    });
                } catch (error) {
                    console.error('Error fetching leaderboard:', error);
                }
            }
            return leaderboards;
        }

        // Store leaderboards for modal navigation
        let cachedLeaderboards = [];
        let currentLeagueIndex = 0;

        function renderPlayerRankings(leaderboards) {
            const playerRankings = document.getElementById('playerRankings');

            if (leaderboards.length === 0) {
                playerRankings.classList.add('hidden');
                return;
            }

            const userId = getCurrentUserId();
            playerRankings.innerHTML = leaderboards.map(lb => {
                const me = lb.leaderboard.find(p => p.uuid === userId);
                const totalPlayers = lb.leaderboard.length;
                const rankText = me?.rank ? `<strong>#${me.rank}</strong> of ${totalPlayers}` : 'Not ranked';

                return `
                    <div class="player-rank-card">
                        <span class="player-rank-league">${lb.league.name}</span>
                        <span class="player-rank-position">${rankText}</span>
                    </div>
                `;
            }).join('');

            playerRankings.classList.remove('hidden');
        }

        function renderLeagueModal(index) {
            if (cachedLeaderboards.length === 0) return;

            currentLeagueIndex = index;
            const lb = cachedLeaderboards[index];

            document.getElementById('leagueModalTitle').textContent = lb.league.name;
            document.getElementById('leagueIndicator').textContent = `${index + 1} / ${cachedLeaderboards.length}`;

            document.getElementById('prevLeagueBtn').disabled = index === 0;
            document.getElementById('nextLeagueBtn').disabled = index === cachedLeaderboards.length - 1;

            document.getElementById('leagueModalLeaderboard').innerHTML = lb.leaderboard.map(player => `
                <div class="leaderboard-item ${player.uuid === getCurrentUserId() ? 'current-player' : ''}">
                    <span class="leaderboard-rank">${player.rank !== null ? '#' + player.rank : '-'}</span>
                    <span class="leaderboard-name">${player.display_name}</span>
                    ${player.mistakes !== null
                        ? `<span class="leaderboard-mistakes">${player.mistakes} mistake${player.mistakes !== 1 ? 's' : ''}</span>`
                        : `<span class="leaderboard-not-played">not yet played</span>`
                    }
                </div>
            `).join('');
        }

        async function checkLeagueUrl() {
            const path = window.location.pathname;
            const match = path.match(/^\/league\/([a-zA-Z0-9-]+)$/);

            if (match) {
                const leagueId = match[1];
                const userId = getCurrentUserId();

                // Check if already a member (only if authenticated)
                if (userId && isAuthenticatedUser()) {
                    try {
                        const { data } = await db
                            .from('league_memberships')
                            .select('*')
                            .eq('league_id', leagueId)
                            .eq('player_uuid', userId)
                            .single();

                        if (!data) {
                            // Need to join
                            await joinLeague(leagueId);
                        }
                    } catch (error) {
                        // No membership found, try to join
                        await joinLeague(leagueId);
                    }
                } else {
                    // User is anonymous, require auth to join league
                    if (!requireAuth({ type: 'join_league', leagueId })) {
                        // Will be handled after auth completes
                    }
                }

                // Clear the URL to avoid re-joining on refresh
                window.history.replaceState({}, '', '/');
            }
        }

        // ===== PUZZLE FETCHING =====

        // Get cached puzzle from localStorage
        function getCachedPuzzle() {
            try {
                const cached = localStorage.getItem(PUZZLE_CACHE_KEY);
                if (!cached) return null;

                const { date, puzzle, puzzleNumber: cachedNumber } = JSON.parse(cached);
                const today = getTodayString();

                // Only use cache if it's for today's date
                if (date === today) {
                    return { puzzle, puzzleNumber: cachedNumber };
                }
                return null;
            } catch (e) {
                return null;
            }
        }

        // Save puzzle to localStorage cache
        function cachePuzzle(puzzle, num) {
            try {
                localStorage.setItem(PUZZLE_CACHE_KEY, JSON.stringify({
                    date: puzzle.date,
                    puzzle,
                    puzzleNumber: num
                }));
            } catch (e) {
                console.warn('Failed to cache puzzle:', e);
            }
        }

        // Transform API puzzle format to game format
        function transformPuzzle(apiPuzzle) {
            return {
                date: apiPuzzle.date,
                categories: apiPuzzle.categories.map((cat, index) => ({
                    name: cat.title,
                    colour: GRADIENT_CLASSES[cat.difficulty - 1] || GRADIENT_CLASSES[index],
                    words: cat.words.map(w => w.toUpperCase())
                }))
            };
        }

        // Parse categories if stored as JSON string
        function parsePuzzleCategories(puzzle) {
            if (!puzzle) return null;
            if (typeof puzzle.categories === 'string') {
                try {
                    puzzle.categories = JSON.parse(puzzle.categories);
                } catch (e) {
                    console.error('Failed to parse categories:', e);
                }
            }
            return puzzle;
        }

        // Fetch today's puzzle from Supabase
        async function fetchTodayPuzzle() {
            const today = getTodayString();
            // Support ?date=YYYY-MM-DD for testing/previewing
            const testDate = new URLSearchParams(window.location.search).get('date');
            const targetDate = testDate || today;

            try {
                // Fetch the puzzle for the target date
                const { data: puzzleData, error } = await db
                    .from('puzzles')
                    .select('*')
                    .eq('date', targetDate)
                    .single();

                if (error || !puzzleData) {
                    throw new Error('Failed to fetch puzzle');
                }

                // Calculate puzzle number (count of puzzles up to this date)
                const { count } = await db
                    .from('puzzles')
                    .select('*', { count: 'exact', head: true })
                    .lte('date', targetDate);

                const parsed = parsePuzzleCategories(puzzleData);
                const puzzle = transformPuzzle(parsed);
                puzzleNumber = count || 1;

                // Cache the puzzle
                cachePuzzle(puzzle, puzzleNumber);

                return puzzle;
            } catch (error) {
                console.error('Error fetching puzzle from Supabase:', error);

                // Try to use cached puzzle as fallback
                const cached = getCachedPuzzle();
                if (cached) {
                    console.log('Using cached puzzle');
                    puzzleNumber = cached.puzzleNumber;
                    return cached.puzzle;
                }

                return null;
            }
        }

        // Fetch puzzle for a specific date (for archive)
        async function fetchPuzzleByDate(date) {
            try {
                const { data: puzzleData, error } = await db
                    .from('puzzles')
                    .select('*')
                    .eq('date', date)
                    .single();

                if (error || !puzzleData) {
                    throw new Error('Failed to fetch puzzle');
                }

                // Calculate puzzle number
                const { count } = await db
                    .from('puzzles')
                    .select('*', { count: 'exact', head: true })
                    .lte('date', date);

                const parsed = parsePuzzleCategories(puzzleData);
                const puzzle = transformPuzzle(parsed);
                return { puzzle, puzzleNumber: count || 1 };
            } catch (error) {
                console.error('Error fetching puzzle:', error);
                return null;
            }
        }

        // Fetch archive (list of available puzzles)
        async function fetchArchive() {
            try {
                const { data: puzzles, error } = await db
                    .from('puzzles')
                    .select('date')
                    .order('date', { ascending: true });

                if (error) {
                    throw new Error('Failed to fetch archive');
                }

                // Return dates with puzzle numbers
                return (puzzles || []).map((p, index) => ({
                    date: p.date,
                    puzzleNumber: index + 1
                }));
            } catch (error) {
                console.error('Error fetching archive:', error);
                return [];
            }
        }

        // ===== RENDER =====
        function renderGrid() {
            gridEl.innerHTML = '';
            remainingWords.forEach((word) => {
                const tile = document.createElement('button');
                tile.className = 'tile';
                const span = document.createElement('span');
                span.textContent = word;
                tile.appendChild(span);
                tile.dataset.word = word;
                if (selectedWords.includes(word)) {
                    tile.classList.add('selected');
                }
                tile.addEventListener('click', () => handleTileClick(word));
                gridEl.appendChild(tile);
            });
            // Scale text to fit tiles
            requestAnimationFrame(() => scaleTileText());
        }

        function scaleTileText() {
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(tile => {
                const span = tile.querySelector('span');
                if (!span) return;
                span.style.transform = 'scale(1)';
                const tileWidth = tile.clientWidth - 8; // account for padding
                const spanWidth = span.scrollWidth;
                if (spanWidth > tileWidth) {
                    const scale = Math.max(0.5, tileWidth / spanWidth);
                    span.style.transform = `scale(${scale})`;
                }
            });
        }

        function renderMistakes() {
            const pips = mistakesEl.querySelectorAll('.mistake-pip');
            pips.forEach((pip, i) => {
                pip.classList.toggle('used', i < mistakes);
            });
        }

        function renderSolvedCategory(category) {
            const el = document.createElement('div');
            el.className = `solved-category ${category.colour}`;
            el.innerHTML = `
                <div class="solved-category-name"><span>${category.name}</span></div>
                <div class="solved-category-words"><span>${category.words.join(', ')}</span></div>
            `;
            solvedAreaEl.appendChild(el);
            // Scale text after render
            requestAnimationFrame(() => scaleSolvedCategoryText(el));
        }

        function scaleSolvedCategoryText(container) {
            const nameEl = container.querySelector('.solved-category-name');
            const wordsEl = container.querySelector('.solved-category-words');
            const containerWidth = container.clientWidth - 40; // account for padding

            [nameEl, wordsEl].forEach(el => {
                const span = el.querySelector('span');
                if (!span) return;
                span.style.transform = 'scale(1)';
                const spanWidth = span.scrollWidth;
                if (spanWidth > containerWidth) {
                    const scale = Math.max(0.5, containerWidth / spanWidth);
                    span.style.transform = `scale(${scale})`;
                }
            });
        }

        function updateButtons() {
            submitBtn.disabled = selectedWords.length !== 4;
            submitBtn.classList.toggle('visible', selectedWords.length === 4);
            deselectBtn.style.opacity = selectedWords.length > 0 ? '1' : '0.5';
        }

        // ===== GAME LOGIC =====
        function handleTileClick(word) {
            if (gameOver) return;

            if (selectedWords.includes(word)) {
                selectedWords = selectedWords.filter(w => w !== word);
            } else if (selectedWords.length < 4) {
                selectedWords.push(word);
            }

            renderGrid();
            updateButtons();
        }

        function checkGuess() {
            for (const category of currentPuzzle.categories) {
                if (solvedCategories.includes(category)) continue;
                const matches = selectedWords.filter(w => category.words.includes(w));
                if (matches.length === 4) {
                    return { correct: true, category };
                }
            }
            return { correct: false };
        }

        function checkOneAway() {
            for (const category of currentPuzzle.categories) {
                if (solvedCategories.includes(category)) continue;
                const matches = selectedWords.filter(w => category.words.includes(w));
                if (matches.length === 3) {
                    return true;
                }
            }
            return false;
        }

        async function handleSubmit() {
            if (selectedWords.length !== 4 || gameOver) return;

            const categoryIndex = currentPuzzle.categories.findIndex(cat => {
                if (solvedCategories.includes(cat)) return false;
                return selectedWords.every(w => cat.words.includes(w));
            });

            if (categoryIndex !== -1) {
                guessHistory.push(categoryIndex);
            } else {
                guessHistory.push(-1);
            }

            const result = checkGuess();

            if (result.correct) {
                await animateCorrectGuess(result.category);
            } else {
                await animateWrongGuess();
            }
        }

        async function animateCorrectGuess(category) {
            // Get tiles and their positions for particles
            const tiles = document.querySelectorAll('.tile.selected');
            const gridRect = gridEl.getBoundingClientRect();

            // Add solving animation
            tiles.forEach(tile => tile.classList.add('solving'));

            await sleep(400);

            // Create particles at center
            const centerX = gridRect.left + gridRect.width / 2;
            const centerY = gridRect.top + gridRect.height / 2;
            const colors = ['#F5D800', '#6CC66C', '#36DFE7', '#7E4E7E']; // Yellow, green, cyan, purple
            const colorIndex = GRADIENT_CLASSES.indexOf(category.colour);
            createParticles(centerX, centerY, colors[colorIndex]);

            // Update state
            solvedCategories.push(category);
            remainingWords = remainingWords.filter(w => !category.words.includes(w));
            selectedWords = [];

            renderSolvedCategory(category);
            renderGrid();
            updateButtons();

            if (solvedCategories.length === 4) {
                await sleep(500);
                handleWin();
            }
        }

        async function animateWrongGuess() {
            const isOneAway = checkOneAway();
            const tiles = document.querySelectorAll('.tile.selected');

            tiles.forEach(tile => tile.classList.add('shake'));
            await sleep(500);
            tiles.forEach(tile => tile.classList.remove('shake'));

            if (isOneAway) {
                showToast('One away...');
            }

            mistakes++;
            renderMistakes();
            selectedWords = [];
            renderGrid();
            updateButtons();

            if (mistakes >= 4) {
                await sleep(300);
                handleLoss();
            }
        }

        async function handleWin() {
            gameOver = true;

            const stats = getStats();

            stats.played[currentDate] = {
                won: true,
                mistakes: mistakes,
                guessHistory: guessHistory
            };

            // Only update streak if playing today's puzzle
            const today = getTodayString();
            if (currentDate === today) {
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                const yesterdayStr = yesterday.toISOString().split('T')[0];

                if (stats.played[yesterdayStr]?.won) {
                    stats.streak++;
                } else {
                    stats.streak = 1;
                }
                stats.maxStreak = Math.max(stats.maxStreak, stats.streak);
            }

            saveStats(stats);
            updateStatsDisplay();

            // Submit score to leagues
            await submitScore(mistakes);

            // Pick win message
            const winMessages = mistakes === 0
                ? ['Clean sweep.', 'Flawless.', 'Textbook.']
                : ['Sorted.', 'Not bad at all.', 'Well played.', 'Nicely done.'];
            endMessage.textContent = winMessages[Math.floor(Math.random() * winMessages.length)];

            // Fetch and render player rankings
            cachedLeaderboards = await fetchLeaderboards();
            renderPlayerRankings(cachedLeaderboards);

            showEndScreen();
        }

        async function handleLoss() {
            gameOver = true;

            const stats = getStats();

            stats.played[currentDate] = {
                won: false,
                mistakes: mistakes,
                guessHistory: guessHistory
            };

            // Only reset streak if playing today's puzzle
            const today = getTodayString();
            if (currentDate === today) {
                stats.streak = 0;
            }
            saveStats(stats);
            updateStatsDisplay();

            // Submit score to leagues (4 mistakes = loss)
            await submitScore(mistakes);

            // Reveal remaining categories
            for (const cat of currentPuzzle.categories) {
                if (!solvedCategories.includes(cat)) {
                    solvedCategories.push(cat);
                    renderSolvedCategory(cat);
                    remainingWords = remainingWords.filter(w => !cat.words.includes(w));
                    renderGrid();
                    await sleep(400);
                }
            }

            const loseMessages = ['Better luck tomorrow.', 'Tough one today.', 'They can\'t all be winners.'];
            endMessage.textContent = loseMessages[Math.floor(Math.random() * loseMessages.length)];

            // Fetch and render player rankings
            cachedLeaderboards = await fetchLeaderboards();
            renderPlayerRankings(cachedLeaderboards);

            showEndScreen();
        }

        function showEndScreen() {
            // Build end categories
            endCategories.innerHTML = '';
            currentPuzzle.categories.forEach((cat, i) => {
                const el = document.createElement('div');
                el.className = `solved-category ${cat.colour} end-category`;
                el.innerHTML = `
                    <div class="solved-category-name"><span>${cat.name}</span></div>
                    <div class="solved-category-words"><span>${cat.words.join(', ')}</span></div>
                `;
                endCategories.appendChild(el);

                setTimeout(() => {
                    el.classList.add('revealed');
                    // Scale text after reveal animation
                    requestAnimationFrame(() => scaleSolvedCategoryText(el));
                }, i * 150);
            });

            // Show View Leagues button if player has leagues
            const viewLeaguesBtn = document.getElementById('viewLeaguesBtn');
            if (cachedLeaderboards.length > 0) {
                viewLeaguesBtn.classList.remove('hidden');
            } else {
                viewLeaguesBtn.classList.add('hidden');
            }

            // Show auth prompt on end screen
            updateAuthUI();

            // Start countdown
            updateCountdown();
            setInterval(updateCountdown, 1000);

            setTimeout(() => {
                endScreen.classList.add('visible');
            }, 600);
        }

        function updateCountdown() {
            const ms = getTimeUntilMidnight();
            countdownEl.textContent = formatCountdown(ms);
        }

        function generateShareText() {
            const stats = getStats();
            const result = stats.played[currentDate];

            if (!result) {
                return null;
            }

            const emoji = result.won ? (result.mistakes === 0 ? 'ðŸ†' : 'âœ…') : 'âŒ';

            let grid = '';
            for (const guess of result.guessHistory) {
                if (guess >= 0) {
                    grid += SHARE_EMOJIS[guess].repeat(4) + '\n';
                } else {
                    grid += 'â¬›â¬›â¬›â¬›\n';
                }
            }
            // Add remaining solved categories if won
            if (result.won && result.guessHistory.length < 4) {
                const remaining = [0, 1, 2, 3].filter(i => !result.guessHistory.includes(i));
                for (const i of remaining) {
                    grid += SHARE_EMOJIS[i].repeat(4) + '\n';
                }
            }

            return `Connections UK #${puzzleNumber} ${emoji}\n\n${grid.trim()}\n\nPlay at: ${window.location.origin}`;
        }

        async function handleShare() {
            const text = generateShareText();

            if (!text) {
                showToast('Complete the puzzle first');
                return;
            }

            // Try native share API first (works on mobile)
            if (navigator.share) {
                try {
                    await navigator.share({ text });
                    return;
                } catch (e) {
                    // User cancelled or share failed, fall through to clipboard
                    if (e.name === 'AbortError') return;
                }
            }

            // Fallback to clipboard
            try {
                await navigator.clipboard.writeText(text);
                showToast('Copied to clipboard');
            } catch {
                // Final fallback: create a temporary textarea
                try {
                    const textarea = document.createElement('textarea');
                    textarea.value = text;
                    textarea.style.position = 'fixed';
                    textarea.style.opacity = '0';
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    showToast('Copied to clipboard');
                } catch {
                    showToast('Could not copy');
                }
            }
        }

        function handleShuffle() {
            if (gameOver) return;
            remainingWords = shuffle(remainingWords);
            renderGrid();
        }

        function handleDeselect() {
            selectedWords = [];
            renderGrid();
            updateButtons();
        }

        // ===== MODALS =====
        function openModal(modal) {
            modal.classList.add('visible');
        }

        function closeModal(modal) {
            modal.classList.remove('visible');
        }

        // ===== ARCHIVE =====
        async function populateArchive() {
            archiveList.innerHTML = '<div class="loading-text">Loading archive...</div>';
            const stats = getStats();

            // Fetch archive from API
            const archive = await fetchArchive();

            archiveList.innerHTML = '';

            // Sort by date descending
            const sortedArchive = archive.sort((a, b) => b.date.localeCompare(a.date));

            sortedArchive.forEach((puzzleInfo) => {
                const played = stats.played[puzzleInfo.date];

                const item = document.createElement('div');
                item.className = `archive-item ${played ? 'played' : ''}`;
                item.dataset.date = puzzleInfo.date;

                let statusHTML = '';
                if (played) {
                    const resultEmojis = played.guessHistory.map(g =>
                        g >= 0 ? SHARE_EMOJIS[g] : 'â¬›'
                    ).join('');
                    statusHTML = `
                        <div class="archive-item-result"><span>${resultEmojis}</span></div>
                        <span class="archive-item-badge ${played.won ? 'won' : 'lost'}">${played.won ? 'Won' : 'Lost'}</span>
                    `;
                } else {
                    statusHTML = `<span class="archive-item-badge play">Play</span>`;
                }

                item.innerHTML = `
                    <div class="archive-item-info">
                        <div class="archive-item-date">${formatDateForDisplay(puzzleInfo.date)}</div>
                        <div class="archive-item-number">Puzzle #${puzzleInfo.puzzleNumber}</div>
                    </div>
                    <div class="archive-item-status">
                        ${statusHTML}
                    </div>
                `;

                if (!played) {
                    item.addEventListener('click', () => {
                        closeModal(archiveModal);
                        loadPuzzle(puzzleInfo.date);
                    });
                }

                archiveList.appendChild(item);
            });
        }

        async function loadPuzzle(date) {
            // Fetch puzzle from API
            const result = await fetchPuzzleByDate(date);
            if (!result) {
                showToast('Failed to load puzzle');
                return;
            }

            const { puzzle, puzzleNumber: num } = result;

            // Reset game state
            currentPuzzle = puzzle;
            currentDate = date;
            puzzleNumber = num;
            remainingWords = [];
            selectedWords = [];
            solvedCategories = [];
            mistakes = 0;
            gameOver = false;
            guessHistory = [];

            // Clear UI
            solvedAreaEl.innerHTML = '';
            endScreen.classList.remove('visible');

            const stats = getStats();
            if (stats.played[date]) {
                // Already played - show results
                await restoreCompletedGame(date);
            } else {
                // Fresh game
                remainingWords = shuffle(puzzle.categories.flatMap(c => c.words));
                loadingEl.classList.add('hidden');
                noPuzzleEl.classList.add('hidden');
                gameAreaEl.classList.remove('hidden');
                shuffleBtn.classList.remove('hidden');

                renderGrid();
                renderMistakes();
                updateButtons();
            }
        }

        // ===== RESTORE GAME =====
        async function restoreCompletedGame(date = null) {
            const targetDate = date || currentDate;
            const stats = getStats();
            const result = stats.played[targetDate];
            if (!result) return;

            // Restore all solved categories
            for (let i = 0; i < currentPuzzle.categories.length; i++) {
                const cat = currentPuzzle.categories[i];
                solvedCategories.push(cat);
                renderSolvedCategory(cat);
            }
            remainingWords = [];
            renderGrid();

            mistakes = result.mistakes;
            renderMistakes();
            gameOver = true;

            loadingEl.classList.add('hidden');
            gameAreaEl.classList.remove('hidden');

            endMessage.textContent = result.won ? 'Sorted.' : 'Better luck tomorrow.';

            // Fetch leaderboards for restored game
            try {
                await fetchPlayerLeagues();
                cachedLeaderboards = await fetchLeaderboards();
                renderPlayerRankings(cachedLeaderboards);
            } catch (e) {
                console.log('Could not load league data:', e);
            }

            showEndScreen();
        }

        // ===== INIT =====
        async function init() {
            // Initialize auth FIRST (especially important when returning from magic link)
            await initAuth();

            // Event listeners
            submitBtn.addEventListener('click', handleSubmit);
            deselectBtn.addEventListener('click', handleDeselect);
            shuffleBtn.addEventListener('click', handleShuffle);
            shareBtn.addEventListener('click', handleShare);
            rulesBtn.addEventListener('click', () => openModal(rulesModal));
            statsBtn.addEventListener('click', () => {
                updateStatsDisplay();
                openModal(statsModal);
            });
            archiveBtn.addEventListener('click', () => {
                populateArchive();
                openModal(archiveModal);
            });

            // Re-scale text on window resize
            window.addEventListener('resize', () => {
                scaleTileText();
                document.querySelectorAll('.solved-category').forEach(el => scaleSolvedCategoryText(el));
            });

            // League elements
            const createLeagueForm = document.getElementById('createLeagueForm');
            const createLeagueTitle = document.getElementById('createLeagueTitle');
            const leagueCreatedName = document.getElementById('leagueCreatedName');
            const createAnotherBtn = document.getElementById('createAnotherBtn');
            const viewLeaguesBtn = document.getElementById('viewLeaguesBtn');

            function resetCreateLeagueModal() {
                leagueNameInput.value = '';
                createLeagueForm.classList.remove('hidden');
                leagueUrlContainer.classList.add('hidden');
                createLeagueTitle.textContent = 'Create a League';
            }

            // League event listeners
            createLeagueBtn.addEventListener('click', () => {
                // Require authentication to create a league
                if (!requireAuth({ type: 'create_league' })) {
                    return; // Will open auth modal
                }
                resetCreateLeagueModal();
                openModal(createLeagueModal);
            });

            createAnotherBtn.addEventListener('click', () => {
                resetCreateLeagueModal();
            });

            viewLeaguesBtn.addEventListener('click', () => {
                if (cachedLeaderboards.length > 0) {
                    renderLeagueModal(0);
                    openModal(document.getElementById('viewLeaguesModal'));
                }
            });

            document.getElementById('prevLeagueBtn').addEventListener('click', () => {
                if (currentLeagueIndex > 0) {
                    renderLeagueModal(currentLeagueIndex - 1);
                }
            });

            document.getElementById('nextLeagueBtn').addEventListener('click', () => {
                if (currentLeagueIndex < cachedLeaderboards.length - 1) {
                    renderLeagueModal(currentLeagueIndex + 1);
                }
            });

            createLeagueSubmit.addEventListener('click', async () => {
                const name = leagueNameInput.value.trim();
                if (!name) return;

                createLeagueSubmit.disabled = true;
                try {
                    // Ensure we have a name before creating
                    if (!playerName) {
                        pendingLeagueId = null; // Will create after name entry
                        const tempName = name; // Store league name
                        closeModal(createLeagueModal);

                        // Prompt for player name
                        joinLeagueName.textContent = tempName;
                        playerNameInput.value = '';

                        // Special handling: create league after name entry
                        pendingLeagueId = 'CREATE:' + tempName;
                        openModal(joinLeagueModal);
                        return;
                    }

                    const league = await createLeague(name);
                    leagueUrlInput.value = league.url;
                    leagueCreatedName.textContent = `"${name}" created!`;
                    createLeagueForm.classList.add('hidden');
                    leagueUrlContainer.classList.remove('hidden');
                    createLeagueTitle.textContent = 'League Created';
                    await renderLeagueWidget();
                } catch (error) {
                    showToast('Failed to create league');
                } finally {
                    createLeagueSubmit.disabled = false;
                }
            });

            copyLeagueUrl.addEventListener('click', async () => {
                try {
                    await navigator.clipboard.writeText(leagueUrlInput.value);
                    showToast('Link copied!');
                } catch {
                    showToast('Could not copy');
                }
            });

            joinLeagueSubmit.addEventListener('click', async () => {
                const name = playerNameInput.value.trim();
                if (!name) return;

                const userId = getCurrentUserId();
                if (!userId) return;

                joinLeagueSubmit.disabled = true;
                try {
                    setPlayerName(name);

                    // Update player name in Supabase
                    await db
                        .from('players')
                        .upsert({ uuid: userId, display_name: name.trim() }, { onConflict: 'uuid' });

                    if (pendingLeagueId) {
                        if (pendingLeagueId.startsWith('CREATE:')) {
                            // Was creating a league, now create it
                            const leagueName = pendingLeagueId.slice(7);
                            const league = await createLeague(leagueName);
                            closeModal(joinLeagueModal);
                            openModal(createLeagueModal);
                            leagueUrlInput.value = league.url;
                            leagueCreatedName.textContent = `"${leagueName}" created!`;
                            createLeagueForm.classList.add('hidden');
                            leagueUrlContainer.classList.remove('hidden');
                            createLeagueTitle.textContent = 'League Created';
                        } else {
                            // Joining existing league
                            await joinLeague(pendingLeagueId);
                            closeModal(joinLeagueModal);
                            showToast('Joined league!');
                        }
                        pendingLeagueId = null;
                    }

                    await renderLeagueWidget();
                } catch (error) {
                    showToast('Failed to join');
                } finally {
                    joinLeagueSubmit.disabled = false;
                }
            });

            // Modal close buttons
            document.querySelectorAll('.modal-close').forEach(btn => {
                btn.addEventListener('click', () => {
                    const modal = btn.closest('.modal-overlay');
                    // Reset auth modal state when closed
                    if (modal.id === 'authRequiredModal') {
                        pendingAuthAction = null;
                        authModalEmail.value = '';
                        authModalEmail.classList.remove('hidden');
                        authModalSubmit.classList.remove('hidden');
                        authModalSuccess.classList.add('hidden');
                        authModalError.classList.add('hidden');
                    }
                    closeModal(modal);
                });
            });

            // Click outside modal to close (but not for join/welcome modals - must complete)
            document.querySelectorAll('.modal-overlay').forEach(overlay => {
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay && overlay.id !== 'joinLeagueModal' && overlay.id !== 'authRequiredModal' && overlay.id !== 'welcomeModal') {
                        closeModal(overlay);
                    }
                });
            });

            // Auth event listeners
            authPromptBtn.addEventListener('click', () => {
                const email = authPromptEmail.value.trim();
                if (email) sendMagicLink(email, false);
            });

            authPromptEmail.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    const email = authPromptEmail.value.trim();
                    if (email) sendMagicLink(email, false);
                }
            });

            authModalSubmit.addEventListener('click', () => {
                const email = authModalEmail.value.trim();
                if (email) sendMagicLink(email, true);
            });

            authModalEmail.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    const email = authModalEmail.value.trim();
                    if (email) sendMagicLink(email, true);
                }
            });

            signOutBtn.addEventListener('click', (e) => {
                e.preventDefault();
                signOut();
            });

            // Welcome modal (set display name after auth)
            welcomeSubmit.addEventListener('click', async () => {
                const name = welcomeNameInput.value.trim();
                if (!name) return;

                welcomeSubmit.disabled = true;
                try {
                    setPlayerName(name);
                    const userId = getCurrentUserId();
                    if (userId) {
                        await db.from('players').upsert({ uuid: userId, display_name: name }, { onConflict: 'uuid' });
                    }
                    closeModal(welcomeModal);
                    await renderLeagueWidget();
                    // Handle any pending action
                    await handlePendingAuthAction();
                } catch (error) {
                    console.error('Error setting name:', error);
                    showToast('Failed to save name');
                } finally {
                    welcomeSubmit.disabled = false;
                }
            });

            welcomeNameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    welcomeSubmit.click();
                }
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    document.querySelectorAll('.modal-overlay.visible').forEach(modal => {
                        if (modal.id !== 'joinLeagueModal' && modal.id !== 'welcomeModal') {
                            closeModal(modal);
                        }
                    });
                }
                if (e.key === 'Enter' && selectedWords.length === 4 && !gameOver) {
                    handleSubmit();
                }
            });

            updateStatsDisplay();

            // Fetch today's puzzle (or test date if ?date= param present)
            const todayPuzzle = await fetchTodayPuzzle();

            if (!todayPuzzle) {
                loadingEl.classList.add('hidden');
                noPuzzleEl.classList.remove('hidden');
                shuffleBtn.classList.add('hidden');
                return;
            }

            currentPuzzle = todayPuzzle;
            currentDate = todayPuzzle.date; // Use the puzzle's actual date

            // Check if already played
            const stats = getStats();
            if (stats.played[currentDate]) {
                loadingEl.classList.add('hidden');
                gameAreaEl.classList.remove('hidden');
                restoreCompletedGame(currentDate);
                return;
            }

            // Start fresh game
            remainingWords = shuffle(currentPuzzle.categories.flatMap(c => c.words));

            loadingEl.classList.add('hidden');
            gameAreaEl.classList.remove('hidden');

            renderGrid();
            renderMistakes();
            updateButtons();

            // Load league features in background (don't block game)
            setTimeout(async () => {
                try {
                    await checkLeagueUrl();
                    await renderLeagueWidget();
                } catch (e) {
                    console.log('League features error:', e);
                }
            }, 100);
        }

        async function fetchLeaderboardsIfNeeded() {
            if (playerLeagues.length > 0 && cachedLeaderboards.length === 0) {
                cachedLeaderboards = await fetchLeaderboards();
            }
        }

        init();
    </script>
</body>
</html>
